<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.supercalifragilisticexpialidociouser.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="像RMI、HTTP invoker等远程调用机制，以及Web服务、RESTful都是同步通信，而消息则属于异步通信。 在异步消息中有两个主要概念：消息代理（message broker）和目的地（destination）。 当一个应用发送信息时，会将消息交给一个消息代理（相当于邮局）。消息代理可以确保消息被投递到指定的目的地，同时解放发送者，使其能够继续进行其他的业务。 有两种通用的目的地：队列（">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringMessage">
<meta property="og:url" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/index.html">
<meta property="og:site_name" content="人见人爱，花见花开，车见爆胎">
<meta property="og:description" content="像RMI、HTTP invoker等远程调用机制，以及Web服务、RESTful都是同步通信，而消息则属于异步通信。 在异步消息中有两个主要概念：消息代理（message broker）和目的地（destination）。 当一个应用发送信息时，会将消息交给一个消息代理（相当于邮局）。消息代理可以确保消息被投递到指定的目的地，同时解放发送者，使其能够继续进行其他的业务。 有两种通用的目的地：队列（">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/point-to-point.png">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/publish-subscribe.png">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/JmsTempate-send.png">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/JmsTemplate-receive.png">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/message-listener.png">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/AMQP.png">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/WebSocket.png">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/STOMP-broker.png">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/STOMP-broker-relay.png">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/UserDestinationMessageHandler.png">
<meta property="og:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/MailSender.png">
<meta property="article:published_time" content="2018-12-12T03:09:46.000Z">
<meta property="article:modified_time" content="2020-05-09T15:25:50.023Z">
<meta property="article:author" content="周千涵">
<meta property="article:tag" content="note">
<meta property="article:tag" content="programming">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="开发">
<meta property="article:tag" content="IT">
<meta property="article:tag" content="技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/SpringMessage/point-to-point.png">

<link rel="canonical" href="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>SpringMessage | 人见人爱，花见花开，车见爆胎</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">人见人爱，花见花开，车见爆胎</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">一个程序猿的笔记</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://blog.supercalifragilisticexpialidociouser.com/2018/12/12/SpringMessage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="周千涵">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="人见人爱，花见花开，车见爆胎">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringMessage
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-12 11:09:46" itemprop="dateCreated datePublished" datetime="2018-12-12T11:09:46+08:00">2018-12-12</time>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>像RMI、HTTP invoker等远程调用机制，以及Web服务、RESTful都是同步通信，而消息则属于异步通信。</p>
<p>在异步消息中有两个主要概念：消息代理（message broker）和目的地（destination）。</p>
<p>当一个应用发送信息时，会将消息交给一个消息代理（相当于邮局）。消息代理可以确保消息被投递到指定的目的地，同时解放发送者，使其能够继续进行其他的业务。</p>
<p>有两种通用的目的地：队列（queue）和主题（topic）。它们分别对应两种消息模型：点对点模型和发布/订阅模型。</p>
<a id="more"></a>

<h1 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h1><h2 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h2><p>在点对点模型中，每一条消息都有一个发送者，并且都只会被一个接收者接收。</p>
<p><img src="SpringMessage/point-to-point.png" alt="点对点模型"></p>
<p>尽管消息队列中中的每条消息只会被一个接收者取走，但是并不意味着只能使用一个接收者从队列中获取消息。事实上，通常会有多个接收者来处理队列中的消息。类似于银行排队办理业务一样，银行柜员类似于接收者。</p>
<p>在点对点模型中，如果有多个接收者监听队列，我们是无法知道某条特定消息会由哪一个接收者处理。</p>
<h2 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布/订阅模型"></a>发布/订阅模型</h2><p>在发布/订阅模型中，消息会发送给一个主题。与队列类似，多个接收者都可以监听一个主题。但是，与队列不同的是，消息不再是只投递给一个接收者，而是主题的所有订阅者都会接收到此消息的副本。类似于杂志发行商与杂志订阅者。</p>
<p><img src="SpringMessage/publish-subscribe.png" alt="发布/订阅模型"></p>
<h1 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h1><p>JMS（Java Message Service）是一个Java标准，定义了使用消息代理的通用API。</p>
<h2 id="安装消息代理"><a href="#安装消息代理" class="headerlink" title="安装消息代理"></a>安装消息代理</h2><p>ActiveMQ是使用JMS进行异步消息传递的最佳选择。</p>
<p>首先，下载并解压发行包；</p>
<p>然后，在<code>解压目录/bin/指定操作系统子目录/</code>下，运行<code>activemq start</code>来启动ActiveMQ。</p>
<p>另外，要将解压目录下的<code>activemq-core-x.x.x.jar</code>添加到应用程序的类路径中，这样在应用程序中就可以使用ActiveMQ的API了。</p>
<h2 id="创建连接工厂"><a href="#创建连接工厂" class="headerlink" title="创建连接工厂"></a>创建连接工厂</h2><p>应用程序需要借助JMS连接工厂通过消息代理发送消息，所以我们还要配置JMS连接工厂，让它知道如何连接到ActiveMQ。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.apache.activemq.spring.ActiveMQConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:brokerURL</span>=<span class="string">"tcp://localhost:60000"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果省略<code>brokerURL</code>属性，则ActiveMQ代理默认监听<code>localhost</code>的61616端口。</p>
<p>另外，也可以使用ActiveMQ自己的Spring配置命名空间来声明连接工厂：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jms</span>=<span class="string">"http://www.springframework.org/schema/jms"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://activemq.apache.org/schema/core</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://activemq.apache.org/schema/core/activemq-core.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/jms</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/jms/spring-jms.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">amq:connectionFactory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">brokerURL</span>=<span class="string">"tcp://localhost:61616"</span>/&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="声明消息目的地"><a href="#声明消息目的地" class="headerlink" title="声明消息目的地"></a>声明消息目的地</h2><p>消息目的地可以是一个队列，也可以是一个主题，这取决于应用的需求。</p>
<h3 id="声明队列"><a href="#声明队列" class="headerlink" title="声明队列"></a>声明队列</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"spittleQueue"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:_</span>=<span class="string">"spitter.queue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">amq:queue</span> <span class="attr">id</span>=<span class="string">"spittleQueue"</span> <span class="attr">physicalName</span>=<span class="string">"spittle.queue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="声明主题"><a href="#声明主题" class="headerlink" title="声明主题"></a>声明主题</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"spittleTopic"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:_</span>=<span class="string">"spitter.topic"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">amq:topic</span> <span class="attr">id</span>=<span class="string">"spittleTopic"</span> <span class="attr">physicalName</span>=<span class="string">"spittle.topic"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用传统的JMS"><a href="#使用传统的JMS" class="headerlink" title="使用传统的JMS"></a>使用传统的JMS</h2><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory cf = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Session session = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  conn = cf.createConnection();</span><br><span class="line">  session = conn.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">  Destination destination = <span class="keyword">new</span> ActiveMQQueue(<span class="string">"spitter.queue"</span>);</span><br><span class="line">  MessageProducer producer = session.createProducer(destination);</span><br><span class="line">  TextMessage message = session.createTextMessage();</span><br><span class="line">  message.setText(<span class="string">"Hello world!"</span>);</span><br><span class="line">  producer.send(message);</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">  <span class="comment">// handle exception?</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">      session.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">      conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (JMSException ex) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory cf = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://localhost:61616"</span>);</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Session session = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  conn = cf.createConnection();</span><br><span class="line">  conn.start();</span><br><span class="line">  session = conn.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">  Destination destination = <span class="keyword">new</span> ActiveMQQueue(<span class="string">"spitter.queue"</span>);</span><br><span class="line">  MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line">  Message message = consumer.receive();</span><br><span class="line">  TextMessage textMessage = (TextMessage) message;</span><br><span class="line">  System.out.println(<span class="string">"GOT A MESSAGE: "</span> + textMessage.getText());</span><br><span class="line">  conn.start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">  <span class="comment">// handle exception?</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">      session.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">      conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (JMSException ex) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用JmsTemplate"><a href="#使用JmsTemplate" class="headerlink" title="使用JmsTemplate"></a>使用JmsTemplate</h2><h3 id="注册JmsTemplate-Bean"><a href="#注册JmsTemplate-Bean" class="headerlink" title="注册JmsTemplate Bean"></a>注册JmsTemplate Bean</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:_-ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="设置默认目的地"><a href="#设置默认目的地" class="headerlink" title="设置默认目的地"></a>设置默认目的地</h4><p>如果总是将消息发送给或接收自相同的目的地，则可以为<code>JmsTempate</code>装配一个默认的目的地。这样，每次发送或接收消息时就不需要指定一个目的地了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:_-ref</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:defaultDestinationName</span>=<span class="string">"spittle.queue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>defaultDestinationName</code>属性只是指定了一个目的地的名称，它没有说明目的地是什么类型。如果已经存在该名称的队列或主题，就会使用已有的。否则，将会创建一个新的目的地（通常会是队列）。</p>
<p>如果想指定要创建的目的地类型，则需要使用<code>defaultDestination-ref</code>属性将之前创建的队列或主题的目的地Bean装配进来：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:_-ref</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:defaultDestination-ref</span>=<span class="string">"spittleTopic"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在调用<code>JmsTempate</code>的<code>send</code>方法时，我们可以省略目的地参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jmsOperations.send(</span><br><span class="line">  <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AlertService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sendSpittleAlert</span><span class="params">(Spittle spittle)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertServiceImpl</span> <span class="keyword">implements</span> <span class="title">AlertService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> JmsOperations jmsOperations;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AlertServiceImpl</span><span class="params">(JmsOperations jmsOperatons)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.jmsOperations = jmsOperations;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSpittleAlert</span><span class="params">(<span class="keyword">final</span> Spittle spittle)</span> </span>&#123;</span><br><span class="line">    jmsOperations.send(</span><br><span class="line">      <span class="string">"spittle.queue"</span>,  <span class="comment">//指定目的地</span></span><br><span class="line">      <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> session.createObjectMessage(spittle); <span class="comment">//创建消息</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JmsOperation</code>是<code>JmsTemplate</code>所实现的接口。</p>
<p><img src="SpringMessage/JmsTempate-send.png" alt="使用JmsTempate发送消息"></p>
<h4 id="对消息进行转换"><a href="#对消息进行转换" class="headerlink" title="对消息进行转换"></a>对消息进行转换</h4><p>除了<code>send</code>方法外，<code>JmsTemplate</code>还提供了<code>convertAndSend</code>方法，它不需要<code>MessageCreator</code>作为参数，而是使用内置的消息转换器为我们创建消息，然后发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSpittleAlert</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">  jmsOperations.convertAndSend(spittle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring提供的消息转换器：</p>
<table>
<thead>
<tr>
<th>消息转换器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>MappingJacksonMessageConverter</td>
<td>使用Jackson JSON库实现消息与JSON格式之间的相互转换。</td>
</tr>
<tr>
<td>MappingJackson2MessageConverter</td>
<td>使用Jackson 2 JSON库实现消息与JSON格式之间的相互转换。</td>
</tr>
<tr>
<td>MarshallingMessageConverter</td>
<td>使用JAXB库实现消息与XML格式之间的相互转换。</td>
</tr>
<tr>
<td>SimpleMessageConverter</td>
<td>实现<code>String</code>与<code>TextMessage</code>之间，字节数组与<code>BytesMessage</code>，<code>Map</code>与<code>MapMessage</code>之间，<code>Serializable</code>对象与<code>ObjectMessage</code>之间的相互转换。</td>
</tr>
</tbody></table>
<p>默认情况下，<code>JmsTemplate</code>在<code>convertAndSend</code>方法中使用<code>SimpleMessageConverter</code>。如果要自己指定消息转换器，则首先声明一个消息转换器Bean，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageConverter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"org.springframework.jms.support.converter.MappingJacksonMessageConverter"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>各个消息转换器可能会需要配置一些额外的属性。</p>
</blockquote>
<p>然后，将其注入到<code>JmsTemplate</code> Bean中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:_-ref</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:defaultDestinationName</span>=<span class="string">"spittle.alert.queue"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:messageConverter-ref</span>=<span class="string">"messageConverter"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果内置的消息转换器满足不了需求，则可以自己实现消息转换器，然后将其注入到<code>JmsTemplate</code> Bean中。自定义的消息转换器要实现<code>MessageConverter</code>接口。</p>
<h3 id="接收消息-1"><a href="#接收消息-1" class="headerlink" title="接收消息"></a>接收消息</h3><h4 id="同步接收"><a href="#同步接收" class="headerlink" title="同步接收"></a>同步接收</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Spittle <span class="title">receiveSpittleAlert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ObjectMessage receivedMessage =</span><br><span class="line">      (ObjectMessage) jmsOperations.receive(); <span class="comment">//从默认目的地接收消息</span></span><br><span class="line">    <span class="keyword">return</span> (Spittle) receivedMessage.getObject();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (JMSException jmsException) &#123; <span class="comment">//由gerObject()抛出</span></span><br><span class="line">    <span class="keyword">throw</span> JmsUtils.convertJmsAccessException(jmsException); <span class="comment">//抛出转换后的非检查型异常</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="SpringMessage/JmsTemplate-receive.png" alt="使用JmsTemplate接收消息"></p>
<p><code>receive</code>方法会尝试从消息代理中获取一条消息，如果没有可用的消息，它会一直等待，直到获得消息（或超时）为止。</p>
<p><code>JmsTemplate</code>只能处理自己方法抛出的<code>JMSException</code>异常，它无法处理<code>ObjectMessage</code>的<code>getObject</code>方法所抛出的<code>JMSException</code>异常。因此，我们要么捕获<code>JMSException</code>异常，要么声明抛出<code>JMSException</code>异常。这里，使用Spring中JmsUtils的<code>convertJmsAccessException</code>方法把检查型异常<code>JMSException</code>转换为非检查型异常<code>JmsException</code>。</p>
<p>同步接收消息也可以使用消息转换器，也就是使用<code>JmsTemplate</code>的<code>receiveAndConvert</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Spittle <span class="title">retrieveSpittleAlert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Spittle) jmsOperations.receiveAndConvert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在没有必要将<code>Message</code>转换为<code>ObjectMessage</code>，也没有必要通过调用<code>getObject</code>方法来获取<code>Spittle</code>，更无需担心检查型异常<code>JMSException</code>。</p>
<p>使用<code>JmsTemplate</code>接收消息的最大缺点在于<code>receive</code>方法和<code>receiveAndConvert</code>方法都是同步的，它们会一直阻塞，直到有可用消息（或者直到超时）。</p>
<h2 id="使用消息驱动POJO：异步接收"><a href="#使用消息驱动POJO：异步接收" class="headerlink" title="使用消息驱动POJO：异步接收"></a>使用消息驱动POJO：异步接收</h2><h3 id="创建消息监听器"><a href="#创建消息监听器" class="headerlink" title="创建消息监听器"></a>创建消息监听器</h3><p>Spring的消息监听器类就是一个POJO：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleAlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleSpittleAlert</span><span class="params">(Spittle spittle)</span> </span>&#123; <span class="comment">//处理方法</span></span><br><span class="line">    <span class="comment">// ... implementation goes here...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置消息监听器"><a href="#配置消息监听器" class="headerlink" title="配置消息监听器"></a>配置消息监听器</h3><p>首先，将上面创建的消息监听器类配置成Bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"spittleHandler"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.habuma.spittr.alerts.SpittleAlertHandler"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，把这个Bean注册为消息监听器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jms:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jms:listener</span> <span class="attr">destination</span>=<span class="string">"spitter.queue"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">ref</span>=<span class="string">"spittleHandler"</span> <span class="attr">method</span>=<span class="string">"handleSpittleAlert"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jms:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>消息监听器容器是一个特殊Bean，它可以监控JMS目的地并等待消息到达。一旦有消息到达，它取出消息，然后把消息传给任意一个对此消息感兴趣的消息监听器。</p>
<p><img src="SpringMessage/message-listener.png" alt="消息监听器"></p>
<p><code>connection-factory</code>属性配置了对<code>connectionFactory</code>的引用，容器中每个消息监听器都使用这个连接工厂进行消息监听。在本例中，<code>connection-factory</code>属性可以移除，因为该属性的默认值就是<code>connectionFactory</code>。</p>
<p>另外，如果<code>ref</code>引用的Bean实现了<code>MessageListener</code>接口，则<code>method</code>属性也可移除，这时默认就是<code>onMessage</code>方法。</p>
<h2 id="使用基于消息的RPC"><a href="#使用基于消息的RPC" class="headerlink" title="使用基于消息的RPC"></a>使用基于消息的RPC</h2><p>现在我们将了解一下如何使用JMS作为传输通道来进行远程调用。</p>
<p>为了支持基于消息的RPC，Spring提供了<code>JmsInvokerServiceExporter</code>，它可以把Bean导出为基于消息的服务；为客户端提供了<code>JmsInvokerProxyFactoryBean</code>来使用这些服务。</p>
<h3 id="导出基于JMS的服务"><a href="#导出基于JMS的服务" class="headerlink" title="导出基于JMS的服务"></a>导出基于JMS的服务</h3><p>要导出的服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AlertService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sendSpittleAlert</span><span class="params">(Spittle spittle)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"alertService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertServiceImpl</span> <span class="keyword">implements</span> <span class="title">AlertService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line">  <span class="keyword">private</span> String alertEmailAddress;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AlertServiceImpl</span><span class="params">(JavaMailSender mailSender,</span></span></span><br><span class="line"><span class="function"><span class="params">                          String alertEmailAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mailSender = mailSender;</span><br><span class="line">    <span class="keyword">this</span>.alertEmailAddress = alertEmailAddress;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSpittleAlert</span><span class="params">(<span class="keyword">final</span> Spittle spittle)</span> </span>&#123;</span><br><span class="line">    SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">    String spitterName = spittle.getSpitter().getFullName();</span><br><span class="line">    message.setFrom(<span class="string">"noreply@spitter.com"</span>);</span><br><span class="line">    message.setTo(alertEmailAddress);</span><br><span class="line">    message.setSubject(<span class="string">"New spittle from "</span> + spitterName);</span><br><span class="line">    message.setText(spitterName + <span class="string">" says: "</span> + spittle.getText());</span><br><span class="line">    mailSender.send(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置<code>JmsInvokerServiceExporter</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"alertServiceExporter"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jms.remoting.JmsInvokerServiceExporter"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:service-ref</span>=<span class="string">"alertService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:serviceInterface</span>=<span class="string">"com.habuma.spittr.alerts.AlertService"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>JmsInvokerServiceExporter</code>可以充当JMS监听器，因此，我们使用<code>&lt;jms:listener-container&gt;</code>配置它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jms:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jms:listener</span> <span class="attr">destination</span>=<span class="string">"spitter.queue"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">ref</span>=<span class="string">"alertServiceExporter"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jms:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，基于JMS的服务就准备好了，它将等待<code>spitter.queue</code>队列中RPC消息的到达。</p>
<h3 id="使用基于JMS的服务"><a href="#使用基于JMS的服务" class="headerlink" title="使用基于JMS的服务"></a>使用基于JMS的服务</h3><p>在客户端配置<code>JmsInvokerProxyFactoryBean</code>代理来访问JMS服务：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"alertService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jms.remoting.JmsInvokerProxyFactoryBean"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:connectionFactory-ref</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:queueName</span>=<span class="string">"spittle.queue"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">propp:serviceInterface</span>=<span class="string">"com.habuma.spittr.alerts.AlertService"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h1><p>与JMS不同，AMQP的生产者并不会直接将消息发布到队列中，AMQP在消息的生产者和传递信息的队列之间引入了一种间接的机制：Exchange。消息生产者将信息发布到一个Exchange，Exchange会绑定到一个或多个队列上，它负责将信息路由到队列上。</p>
<p><img src="SpringMessage/AMQP.png" alt="AMQP"></p>
<p>AMQP定义了四种不同类型的Exchange：</p>
<ul>
<li>Direct：如果消息的routing key与binding的routing key直接匹配的话，消息将会路由到该队列上；</li>
<li>Topic：如果消息的routing key与binding的routing key符合通配符匹配，则消息将会路由到该队列上；</li>
<li>Headers：如果消息参数表中的头信息和值都与binding参数表中相匹配，则消息将会路由到该队列上；</li>
<li>Fanout：不管消息的routing key和参数表中的头信息/值是什么，消息将会路由到所有队列上。</li>
</ul>
<p>另外，Exchange可以绑定到另一个Exchange上。</p>
<h2 id="创建连接工厂-1"><a href="#创建连接工厂-1" class="headerlink" title="创建连接工厂"></a>创建连接工厂</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/rabbit"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:beans</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">                                 http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                                 http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                                 http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">host</span>=<span class="string">"$&#123;rabbitmq.host&#125;"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">port</span>=<span class="string">"$&#123;rabbitmq.port&#125;"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">username</span>=<span class="string">"$&#123;rabbitmq.username&#125;"</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">password</span>=<span class="string">"$&#123;rabbitmq.password&#125;"</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>host</code>、<code>port</code>、<code>username</code>和<code>password</code>都是可选，如果省略，则RabbitMQ默认监听<code>localhost</code>的5672端口，并且用户名和密码均为<code>guest</code>。</p>
<h2 id="声明队列、Exchange以及binding"><a href="#声明队列、Exchange以及binding" class="headerlink" title="声明队列、Exchange以及binding"></a>声明队列、Exchange以及binding</h2><p>在JMS中，队列和主题的路由行为都是通过规范建立的，而AMQP则不同，它的路由方式可通过队列、Exchange以及binding的各种组合实现。</p>
<p>例如：点对点模型</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">admin</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">queue</span> <span class="attr">id</span>=<span class="string">"spittleAlertQueue"</span> <span class="attr">name</span>=<span class="string">"spittle.alerts"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里会有一个默认的没有名称的Direct Exchange，所有队列都会绑定到这个Exchange上，并且routing key与队列的名称相同。</p>
<p>更复杂的例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">admin</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">queue</span> <span class="attr">name</span>=<span class="string">"spittle.alert.queue.1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">queue</span> <span class="attr">name</span>=<span class="string">"spittle.alert.queue.2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">queue</span> <span class="attr">name</span>=<span class="string">"spittle.alert.queue.3"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fanoutexchange</span> <span class="attr">name</span>=<span class="string">"spittle.fanout"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span> <span class="attr">queue</span>=<span class="string">"spittle.alert.queue.1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span> <span class="attr">queue</span>=<span class="string">"spittle.alert.queue.2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span> <span class="attr">queue</span>=<span class="string">"spittle.alert.queue.3"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bindings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fanoutexchange</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="发送消息-2"><a href="#发送消息-2" class="headerlink" title="发送消息"></a>发送消息</h2><h3 id="注册RabbitTemplate"><a href="#注册RabbitTemplate" class="headerlink" title="注册RabbitTemplate"></a>注册RabbitTemplate</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"rabbitTemplate"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用convertAndSend方法发送消息"><a href="#使用convertAndSend方法发送消息" class="headerlink" title="使用convertAndSend方法发送消息"></a>使用convertAndSend方法发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertServiceImpl</span> <span class="keyword">implements</span> <span class="title">AlertService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> RabbitTemplate rabbit;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AlertServiceImpl</span><span class="params">(RabbitTemplate rabbit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rabbit = rabbit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSpittleAlert</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">    rabbit.convertAndSend(<span class="string">"spittle.alert.exchange"</span>, <span class="comment">//Exchange名称</span></span><br><span class="line">                          <span class="string">"spittle.alerts"</span>,  <span class="comment">//routing key</span></span><br><span class="line">                          spittle);  <span class="comment">//发送的对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，如果在<code>&lt;template</code>上使用<code>exchange</code>和<code>routing-key</code>属性配置默认的Exchange名称和routint key，则在调用<code>convertAndSend</code>方法时，可以省略前两个参数：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"rabbitTemplate"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">exchange</span>=<span class="string">"spittle.alert.exchange"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">routing-key</span>=<span class="string">"spittle.alerts"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbit.convertAndSend(spittle);</span><br></pre></td></tr></table></figure>

<p>最后，如果在<code>&lt;template&gt;</code>和<code>convertAndSend</code>方法中均未指定Exchange名称和routing key，则Exchange名称和routing key均默认为空。</p>
<p>通过<code>convertAndSend</code>方法指定的Exchange名称和routing key，将覆盖<code>&lt;template&gt;</code>的相应配置。</p>
<p><code>convertAndSend</code>方法会自动将对象转换为<code>Message</code>对象。它需要借助一个消息转换器来完成该转换，默认的消息转换器是<code>SimpleMessageConverter</code>，它适用于<code>String</code>、<code>Serializable</code>实例以及字节数组。</p>
<h3 id="使用send方法发送消息"><a href="#使用send方法发送消息" class="headerlink" title="使用send方法发送消息"></a>使用send方法发送消息</h3><p>我们还可以使用较低级的<code>send</code>方法来直接发送<code>org.springframework.amqp.core.Message</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message helloMessage =</span><br><span class="line">  <span class="keyword">new</span> Message(<span class="string">"Hello World!"</span>.getBytes(), <span class="keyword">new</span> MessageProperties());</span><br><span class="line">rabbit.send(<span class="string">"hello.exchange"</span>, <span class="string">"hello.routing"</span>, helloMessage);</span><br></pre></td></tr></table></figure>

<h2 id="接收消息-2"><a href="#接收消息-2" class="headerlink" title="接收消息"></a>接收消息</h2><h3 id="使用RabbitTemplate来同步接收消息"><a href="#使用RabbitTemplate来同步接收消息" class="headerlink" title="使用RabbitTemplate来同步接收消息"></a>使用RabbitTemplate来同步接收消息</h3><h4 id="注册RabbitTemplate-1"><a href="#注册RabbitTemplate-1" class="headerlink" title="注册RabbitTemplate"></a>注册RabbitTemplate</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"rabbitTemplate"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">exchange</span>=<span class="string">"spittle.alert.exchange"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">routing-key</span>=<span class="string">"spittle.alerts"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">queue</span>=<span class="string">"spittle.alert.queue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用receive方法接收消息"><a href="#使用receive方法接收消息" class="headerlink" title="使用receive方法接收消息"></a>使用receive方法接收消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message message = rabbit.receive();</span><br></pre></td></tr></table></figure>

<p><code>receive</code>方法的其他重载版本可以显式指定Exchange名称和routing key来覆盖<code>&lt;tempate&gt;</code>中的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message message = rabbit.receive(<span class="string">"spittle.alert.queue2"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="使用receiveAndConvert方法接收消息"><a href="#使用receiveAndConvert方法接收消息" class="headerlink" title="使用receiveAndConvert方法接收消息"></a>使用receiveAndConvert方法接收消息</h4><p><code>receiveAndConvert</code>方法会使用与<code>sendAndConvert</code>方法相同的消息转换器，来将<code>Message</code>对象转换为原始的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spittle spittle = (Spittle) rabbit.receiveAndConvert();</span><br></pre></td></tr></table></figure>

<h4 id="管理轮询"><a href="#管理轮询" class="headerlink" title="管理轮询"></a>管理轮询</h4><p>调用<code>receive</code>和<code>receiveAndConvert</code>方法都会立即返回。如果队列中没有等待的消息时，将会得到<code>null</code>。这就需要我们来管理轮询（polling）以及必要的线程，实现队列的监控。</p>
<h3 id="使用消息驱动的POJO来异步接收消息"><a href="#使用消息驱动的POJO来异步接收消息" class="headerlink" title="使用消息驱动的POJO来异步接收消息"></a>使用消息驱动的POJO来异步接收消息</h3><p>我们并非必须同步轮询并等待消息到达，Spring AMQP还提供了消息驱动POJO的支持。</p>
<h4 id="创建消息监听器POJO类"><a href="#创建消息监听器POJO类" class="headerlink" title="创建消息监听器POJO类"></a>创建消息监听器POJO类</h4><p>我们可以完全重用JMS的消息监听器POJO类——<code>SpittleAlertHandler</code>，因为它丝毫没有依赖于JMS或AMQP。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleAlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleSpittleAlert</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... implementation goes here ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置消息监听器-1"><a href="#配置消息监听器-1" class="headerlink" title="配置消息监听器"></a>配置消息监听器</h4><p>首先，将上面创建的消息监听器类配置成Bean（与配置JMS消息监听器完全相同）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"spittleListener"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.habuma.spittr.alert.SpittleAlertHandler"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，把这个Bean注册为消息监听器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">"spittleListener"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">method</span>=<span class="string">"handleSpittleAlert"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">queue-names</span>=<span class="string">"spittle.alert.queue"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>queue-names</code>可以设置多个队列的名称，用逗号分割。</p>
<p>另外，还可以使用<code>queues</code>属性来引用一个或多个（用逗号分割）使用<code>&lt;queue&gt;</code>元素声明要监听的队列Bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span> <span class="attr">ref</span>=<span class="string">"spittleListener"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">method</span>=<span class="string">"handleSpittleAlert"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">queues</span>=<span class="string">"spittleAlertQueue"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener-container</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">queue</span> <span class="attr">id</span>=<span class="string">"spittleAlertQueue"</span> <span class="attr">name</span>=<span class="string">"spittle.alert.queue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>JMS和AMQP是用于应用程序之间的通讯，而如果某个应用是运行在Web浏览器中，则就需要使用WebSocket。</p>
<p>WebSocket协议提供了通过一个套接字实现全双工通信（服务器和浏览器可以互相发送消息）的功能，位于WebSocket一端的应用发送消息，另一端处理消息。因为它是全双工的，所以每一端都可以发送和处理消息。</p>
<p><img src="SpringMessage/WebSocket.png" alt="WebSocket"></p>
<p>WebSocket通信可以应用于任何类型的应用中，但是它最常见的应用场景是实现Web浏览器和服务器之间的异步通信。浏览器中的JavaScript客户端开启一个到服务器的连接，服务器通过这个连接发送更新给浏览器。相比历史上轮询服务端以查找更新的方案，这种技术更加高效和自然。</p>
<h2 id="使用Spring的低层级WebSocket-API"><a href="#使用Spring的低层级WebSocket-API" class="headerlink" title="使用Spring的低层级WebSocket API"></a>使用Spring的低层级WebSocket API</h2><h3 id="创建消息处理器"><a href="#创建消息处理器" class="headerlink" title="创建消息处理器"></a>创建消息处理器</h3><p>WebSocket消息处理器是一个实现了<code>WebSocketHandler</code>接口的类。</p>
<p><code>WebSocketHandler</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，创建消息处理器更简便的方法是扩展<code>AbstractWebSocketHandler</code>抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarcoHandler</span> <span class="keyword">extends</span> <span class="title">AbstractWebSocketHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MarcoHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> </span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Received message: "</span> + message.getPayload());</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>); <span class="comment">//模拟延时</span></span><br><span class="line">    session.sendMessage(<span class="keyword">new</span> TextMessage(<span class="string">"Polo!"</span>)); <span class="comment">//发送文本消息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractWebSocketHandler</code>额外定义了三个方法：</p>
<ul>
<li>handleBinaryMessage()</li>
<li>handlePongMessage()</li>
<li>handleTextMessage()</li>
</ul>
<p>这三个方法只是<code>handleMessage()</code>的具体化，每个方法对应于某一种特定类型的消息。</p>
<p>如果只是处理文本消息，则可扩展<code>TextWebSocketHandler</code>类。</p>
<h3 id="启用WebSocket"><a href="#启用WebSocket" class="headerlink" title="启用WebSocket"></a>启用WebSocket</h3><p>启用WebSocket并注册消息处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addHandler(marcoHandler(), <span class="string">"/marco"</span>); <span class="comment">//将MarcoHandler映射到“/marco”</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MarcoHandler <span class="title">marcoHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MarcoHandler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:websocket</span>=<span class="string">"http://www.springframework.org/schema/websocket"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/websocket/spring-websocket.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">handler</span>=<span class="string">"marcoHandler"</span> <span class="attr">path</span>=<span class="string">"/marco"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"marcoHandler"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"marcopolo.MarcoHandler"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript客户端"><a href="#JavaScript客户端" class="headerlink" title="JavaScript客户端"></a>JavaScript客户端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'ws://'</span> + <span class="built_in">window</span>.location.host + <span class="string">'/websocket/marco'</span>;</span><br><span class="line"><span class="keyword">var</span> sock = <span class="keyword">new</span> WebSocket(url); <span class="comment">//打开WebSocket</span></span><br><span class="line">sock.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//处理连接开启事件</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Opening'</span>);</span><br><span class="line">  sayMarco();</span><br><span class="line">&#125;;</span><br><span class="line">sock.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">//处理消息</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received message: '</span>, e.data);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;sayMarco()&#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;;</span><br><span class="line">sock.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//处理连接关闭事件</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Closing'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayMarco</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Sending Marco!'</span>);</span><br><span class="line">  sock.send(<span class="string">"Marco!"</span>); <span class="comment">//发送消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>URL使用了<code>ws://</code>前缀，表明这是一个基本的WebSocket连接。如果是安全WebSocket，则使用<code>wss://</code>前缀。</p>
<h3 id="关闭WebSocket连接"><a href="#关闭WebSocket连接" class="headerlink" title="关闭WebSocket连接"></a>关闭WebSocket连接</h3><p>下列三种场景均可关闭WebSocket连接：</p>
<ul>
<li>客户端调用<code>sock.close()</code>；</li>
<li>服务器端调用<code>session.close()</code>；</li>
<li>浏览器转向其他页面。</li>
</ul>
<h2 id="应对不支持WebSocket的场景——SockJS"><a href="#应对不支持WebSocket的场景——SockJS" class="headerlink" title="应对不支持WebSocket的场景——SockJS"></a>应对不支持WebSocket的场景——SockJS</h2><p>当前不支持WebSocket场景主要由下列三种原因造成：</p>
<ul>
<li>某些浏览器不支持WebSocket；</li>
<li>某些应用服务器不支持WebSocket；</li>
<li>防火墙限制了WebSocket通信。</li>
</ul>
<p>SockJS是WebSocket技术的一种模拟，在表面上，它尽可能对应WebSocket API，但是在底层它非常智能。SockJS会优先选用WebSocket，但是如果WebSocket不可用，则它会从如下方案中挑选最优的可行方案：</p>
<ul>
<li>XHR流</li>
<li>XDR流</li>
<li>iFrame事件源</li>
<li>iFrame HTML文件</li>
<li>XHR轮询</li>
<li>XDR轮询</li>
<li>iFrame XHR轮询</li>
<li>JSONP轮询</li>
</ul>
<h3 id="在服务端启用SockJS"><a href="#在服务端启用SockJS" class="headerlink" title="在服务端启用SockJS"></a>在服务端启用SockJS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">	registry.addHandler(marcoHandler(), <span class="string">"/marco"</span>).withSockJS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过简单地调用<code>withSockJS</code>方法，就能声明我们想要使用的SockJS功能，如果WebSocket不可用，则SockJS的备用方案就会发挥作用。</p>
<p>或者使用XML来配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">websocket:handlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">websocket:mapping</span> <span class="attr">handler</span>=<span class="string">"marcoHandler"</span> <span class="attr">path</span>=<span class="string">"/marco"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">websocket:sockjs</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">websocket:handlers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="在客户端启用SockJS"><a href="#在客户端启用SockJS" class="headerlink" title="在客户端启用SockJS"></a>在客户端启用SockJS</h3><h4 id="加载SockJS客户端库"><a href="#加载SockJS客户端库" class="headerlink" title="加载SockJS客户端库"></a>加载SockJS客户端库</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.sockjs.org/sockjs-0.3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h4><p>只需要在原来基于WebSocket API的代码上修改两行代码就可以使用SockJS：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'marco'</span>;</span><br><span class="line"><span class="keyword">var</span> sock = <span class="keyword">new</span> SockJS(url);</span><br></pre></td></tr></table></figure>

<p>第一个修改就是URL。SockJS所处理的URL是<code>http://</code>或<code>https://</code>模式，而不是<code>ws://</code>或<code>wss://</code>。而且可以使用相对URL，如果包含JavaScript的页面位于<a href="http://localhost:8080/websocket" target="_blank" rel="noopener">http://localhost:8080/websocket</a> ，则本例给定的相对路径<code>marco</code>将对应于<a href="http://localhost:8080/websocket/marco。" target="_blank" rel="noopener">http://localhost:8080/websocket/marco。</a></p>
<p>第二个修改是创建SockJS实例代替WebSocket。</p>
<h2 id="使用STOMP消息"><a href="#使用STOMP消息" class="headerlink" title="使用STOMP消息"></a>使用STOMP消息</h2><p>直接使用WebSocket（或SockJS）就类似于使用TCP套接字来编写Web应用，显得过于低级。因为没有高层级的线路协议（wire protocol），因此就需要我们定义应用之间所发送消息的语义，还需要确保连接的两端都能遵循这些语义。</p>
<p>STOMP在WebSocket之上提供了一个基于帧的线路格式（frame-based wire format）层，用来定义消息的语义。</p>
<p>相比于使用原始的WebSocket，使用STOMP能够带来以下好处：</p>
<ul>
<li>无需发明自定义消息传递协议和消息格式。</li>
<li>有可用的STOMP客户端，包括Spring Framework中的Java客户端。</li>
<li>您可以（可选）使用现成的消息代理（例如RabbitMQ，ActiveMQ等）来管理订阅和广播消息。</li>
<li>可以在任意数量的<code>@Controller</code>实例中组织应用程序逻辑，并且可以基于STOMP <code>destination</code>头将消息路由到它们，而无须使用给定连接的单个<code>WebSocketHandler</code>来处理原始WebSocket消息。</li>
<li>您可以使用Spring Security根据STOMP<code>destination</code>和消息类型来保护消息。</li>
</ul>
<p>STOMP帧在HTTP上建模，由命令、一个或多个头信息以及负载（payloads）所组成，非常类似于HTTP请求结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMMAND</span><br><span class="line">header1:value1</span><br><span class="line">header2:value2</span><br><span class="line"></span><br><span class="line">Body^@</span><br></pre></td></tr></table></figure>

<p>例如：客户端发送消息的STOMP帧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:&#x2F;app&#x2F;marco</span><br><span class="line">content-length:20</span><br><span class="line"></span><br><span class="line">&#123;\&quot;message\&quot;:\&quot;Marco!\&quot;&#125;^@</span><br></pre></td></tr></table></figure>

<p>客户端订阅消息的STOMP帧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE</span><br><span class="line">id:sub-1</span><br><span class="line">destination:&#x2F;topic&#x2F;price.stock.*</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>STOMP服务器广播消息的STOMP帧：（STOMP服务器可以使用MESSAGE命令向所有订阅客户端广播消息）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MESSAGE</span><br><span class="line">message-id:nxahklf6-1</span><br><span class="line">subscription:sub-1</span><br><span class="line">destination:&#x2F;topic&#x2F;price.stock.MMM</span><br><span class="line"></span><br><span class="line">&#123;&quot;ticker&quot;:&quot;MMM&quot;,&quot;price&quot;:129.45&#125;^@</span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务器无法发送未经请求的消息给客户端。也就是说，所有来自服务器的消息都必须响应特定的客户端订阅，并且服务器消息的subscription头必须与客户端订阅的id头匹配。</p>
</blockquote>
<p>尽管STOMP是一种面向文本的协议，但消息负载可以是文本或二进制。</p>
<p>Spring为STOMP消息提供了基于Spring MVC的编程模型，在Spring MVC控制器中处理STOMP消息与处理HTTP请求并没有太大的差别。</p>
<h3 id="启用STOMP消息功能"><a href="#启用STOMP消息功能" class="headerlink" title="启用STOMP消息功能"></a>启用STOMP消息功能</h3><p>spring-messaging和spring-websocket模块提供WebSocket之上的STOMP 支持。一旦有了这些依赖项，就可以通过<a href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#websocket-fallback" target="_blank" rel="noopener">SockJS Fallback</a>在WebSocket上公开STOMP端点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketStompConfig</span> <span class="keyword">extends</span> <span class="title">AbstractWebSocketMessageBrokerConfigurer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将“/marcopolo”注册为STOMP端点，客户端在订阅或发布消息到目的地路径前，要连接该端点。</span></span><br><span class="line">    registry.addEndpoint(<span class="string">"/marcopolo"</span>).withSockJS();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用内置消息代理进行订阅和广播，并将destination头以“/topic”或“/queue”开头的消息路由到代理。</span></span><br><span class="line">    registry.enableSimpleBroker(<span class="string">"/queue"</span>, <span class="string">"/topic"</span>);</span><br><span class="line">    <span class="comment">//destination头以“/app”为前缀的STOMP消息将路由到@Controller类中的@MessageMapping方法。</span></span><br><span class="line">    registry.setApplicationDestinationPrefixes(<span class="string">"/app"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果没有重写<code>configureMessageBroker</code>方法，则会自动配置一个简单的内存消息代理，用它来处理以<code>/topic</code>前缀的消息。只有需要显式配置一个消息代理时，才需要重写这个方法。</p>
</blockquote>
<p>或者：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:websocket</span>=<span class="string">"http://www.springframework.org/schema/websocket"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/websocket</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/websocket/spring-websocket.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">websocket:message-broker</span> <span class="attr">application-destination-prefix</span>=<span class="string">"/app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:stomp-endpoint</span> <span class="attr">path</span>=<span class="string">"/marcopolo"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">websocket:sockjs</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">websocket:stomp-endpoint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">websocket:simple-broker</span> <span class="attr">prefix</span>=<span class="string">"/queue, /topic"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">websocket:message-broker</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="SpringMessage/STOMP-broker.png" alt="STOMP代理"></p>
<blockquote>
<p>图中的三个消息通道如下：</p>
<ul>
<li>clientInboundChannel：用于传递从WebSocket客户端接收到的消息。</li>
<li>clientOutboundChannel：用于将服务器消息发送到WebSocket客户端。</li>
<li>brokerChannel：用于从服务器端应用程序代码中向消息代理发送消息。</li>
</ul>
<p>注意：向clientInboundChannel发送请求消息的客户端，与从clientOutboundChannel订阅响应消息的客户端并不一定是同一个客户端。而且，订阅响应消息的客户端有可能有多个。</p>
</blockquote>
<h4 id="启用STOMP代理中继"><a href="#启用STOMP代理中继" class="headerlink" title="启用STOMP代理中继"></a>启用STOMP代理中继</h4><p>简单的代理是基于内存的，尽管它模拟了STOMP消息代理，但是它只支持STOMP命令的子集，并且它不适合集群环境。在生产环境中，我们会使用真正支持STOMP的代理（例如RabbitMQ或ActiveMQ）来支撑WebSocket消息。</p>
<p><img src="SpringMessage/STOMP-broker-relay.png" alt="STOMP代理中继"></p>
<p>首先，根据相关文档搭建STOMP代理。（略）</p>
<p>然后，按如下方式重载<code>configureMessageBroker</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">  registry.enableStompBrokerRelay(<span class="string">"/topic"</span>, <span class="string">"/queue"</span>);</span><br><span class="line">  registry.setApplicationDestinationPrefixes(<span class="string">"/app"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>destination</code>头以“/topic”或“/queue”开头的消息都会发送到STOMP代理中。根据所选择的STOMP代理不同，<code>destination</code>头的可选前缀也会有所限制。例如，RabbitMQ只允许<code>destination</code>头以<code>/temp-queue</code>、<code>/exchange</code>、<code>/topic</code>、<code>/queue</code>、<code>/amq/queue</code>和<code>/reply-queue</code>。</p>
<p>默认情况下，STOMP代理中继会假设代理监听<code>localhost</code>的61613端口，并且客户端的<code>username</code>和<code>password</code>均为<code>guest</code>。如果需要自己指定这些信息，则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> </span>&#123;</span><br><span class="line">  registry.enableStompBrokerRelay(<span class="string">"/topic"</span>, <span class="string">"/queue"</span>)</span><br><span class="line">    .setRelayHost(<span class="string">"rabbit.someotherserver"</span>)</span><br><span class="line">    .setRelayPort(<span class="number">62623</span>)</span><br><span class="line">    .setClientLogin(<span class="string">"marcopolo"</span>)</span><br><span class="line">    .setClientPasscode(<span class="string">"letmein01"</span>);</span><br><span class="line">  registry.setApplicationDestinationPrefixes(<span class="string">"/app"</span>, <span class="string">"/foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写JavaScript客户端"><a href="#编写JavaScript客户端" class="headerlink" title="编写JavaScript客户端"></a>编写JavaScript客户端</h3><p>要从浏览器连接，对于SockJS，您可以使用<a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="noopener">sockjs-client</a>。对于STOMP，许多应用程序使用了<a href="jmesnil/stomp-websocket">jmesnil/stomp-websocket</a>库（也称为stomp.js），它是功能完备的，已经在生产中使用多年但不再维护。目前，<a href="JSteunou/webstomp-client">JSteunou/webstomp-client</a>是该库中最积极维护和不断发展的继任者。</p>
<p>下面的示例代码基于webstomp-client：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'/'</span> + <span class="built_in">window</span>.location.host + <span class="string">'/stomp/marcopolo'</span>; <span class="comment">//这里“/stomp”是应用上下文路径</span></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> SockJS(url); <span class="comment">//创建SockJS连接</span></span><br><span class="line"><span class="keyword">var</span> stompClient = webstomp.over(socket); <span class="comment">//创建STOMP客户端</span></span><br><span class="line"></span><br><span class="line">stompClient.connect(&#123;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">frame</span>) </span>&#123; <span class="comment">//连接STOMP端点</span></span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，如果通过WebSocket连接（没有SockJS），则可以使用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'/'</span> + <span class="built_in">window</span>.location.host + <span class="string">'/stomp/marcopolo'</span>;</span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(url);</span><br><span class="line"><span class="keyword">var</span> stompClient = Stomp.over(socket);</span><br><span class="line"></span><br><span class="line">stompClient.connect(&#123;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">frame</span>) </span>&#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发送消息-3"><a href="#发送消息-3" class="headerlink" title="发送消息"></a>发送消息</h4><p>可以使用<code>stompClient.send</code>方法来向服务端发送STOMP消息（<code>SEND</code>帧）。</p>
<h5 id="发往控制器方法"><a href="#发往控制器方法" class="headerlink" title="发往控制器方法"></a>发往控制器方法</h5><p>在我们的例子中，<code>destination</code>头以<code>/app</code>为前缀的<code>SEND</code>帧将被路由到<code>@MessageMapping</code>方法或<code>@SubscribeMapping</code>方法进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> payload = <span class="built_in">JSON</span>.stringify(&#123;<span class="string">'message'</span>: <span class="string">'Marco!'</span>&#125;);</span><br><span class="line">stompClient.send(<span class="string">"/app/marco"</span>, payload);</span><br></pre></td></tr></table></figure>

<h5 id="发往代理"><a href="#发往代理" class="headerlink" title="发往代理"></a>发往代理</h5><p>在我们的例子中，<code>destination</code>头以“/topic”或“/queue”开头的消息都会发送到STOMP代理中存储。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stompClient.send(<span class="string">"/topic/marco"</span>, payload);</span><br></pre></td></tr></table></figure>

<h4 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h4><h3 id="处理来自客户端的STOMP消息"><a href="#处理来自客户端的STOMP消息" class="headerlink" title="处理来自客户端的STOMP消息"></a>处理来自客户端的STOMP消息</h3><p>当从WebSocket连接接收客户端发来的STOMP消息时，它们被解码为STOMP帧，然后转换成Spring的 <code>Message</code>对象，并发送到clientInboundChannel以进行进一步处理。例如，destination 头以<code>/app</code>开头的STOMP消息可以路由到控制器中的<code>@MessageMapping</code>方法或<code>@SubscribeMapping</code>方法，而以<code>/topic</code>和<code>/queue</code>开头的消息可以直接路由到消息代理。</p>
<p>带有<code>@Controller</code>标注的控制器可以用来处理来自客户端的destination 头以<code>/app</code>开头的STOMP消息（<code>SEND</code>帧）。并且，如果控制器处理方法有返回值，还会通过brokerChannel向代理发送消息。随后，代理通过clientOutboundChannel将消息广播给匹配的订户。</p>
<h4 id="MessageMapping方法"><a href="#MessageMapping方法" class="headerlink" title="@MessageMapping方法"></a><code>@MessageMapping</code>方法</h4><p><code>@MessageMapping</code>可用在方法级别或类型级别。在类型级别，<code>@MessageMapping</code>用于表示控制器中所有方法的共享映射。</p>
<p><code>@MessageMapping</code>支持的路径模式与<code>@RequestMapping</code>相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarcoController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger =</span><br><span class="line">    LoggerFactory.getLogger(MarcoController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="meta">@MessageMapping</span>(<span class="string">"/marco"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShout</span><span class="params">(Shout incoming)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Received message: "</span> + incoming.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面处理器将接收destination 头为<code>/app/marco</code>的STOMP消息（“/app”前缀是隐含的，因为我们将其配置为应用的目的地前缀——<code>registry.setApplicationDestinationPrefixes(&quot;/app&quot;)</code>。）</p>
<p>这里处理器方法接收一个<code>Shout</code>参数，所以Spring会使用消息转换器将STOMP消息的负载转换为<code>Shout</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shout</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SubscribeMapping方法"><a href="#SubscribeMapping方法" class="headerlink" title="@SubscribeMapping方法"></a><code>@SubscribeMapping</code>方法</h4><p><code>@SubscribeMapping</code>类似于<code>@MessageMapping</code>也是处理<code>destination</code> 头以<code>/app</code>开头的STOMP消息（<code>SEND</code>帧）。</p>
<p><code>@SubscribeMapping</code>只能用在方法级别上，但是，它可以与用在类型级别的<code>@MessageMapping</code>结合使用。</p>
<p><code>@SubscribeMapping</code>与<code>@MessageMapping</code>区别在于：<code>@SubscribeMapping</code>方法的返回值，默认情况下，将作为消息<strong>直接发送回连接的客户端</strong>，而不通过代理。而<code>@MessageMapping</code>方法如果有返回值，则是将返回值作为消息通过代理广播给订阅者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SubscribeMapping</span>(&#123;<span class="string">"/marco"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Shout <span class="title">handleSubscription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Shout outgoing = <span class="keyword">new</span> Shout();</span><br><span class="line">  outgoing.setMessage(<span class="string">"Polo!"</span>);</span><br><span class="line">  <span class="keyword">return</span> outgoing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SubscribeMapping</code>的主要应用场景是实现“请求-响应”模式，并且它是异步的，这不同于HTTP GET的同步式的“请求-响应”模式。</p>
<h4 id="消息处理器方法参数"><a href="#消息处理器方法参数" class="headerlink" title="消息处理器方法参数"></a>消息处理器方法参数</h4><p><code>@SubscribeMapping</code>方法、<code>@MessageMapping</code>方法，以及<code>@MessageExceptionHandler</code>方法的参数：</p>
<ul>
<li><code>Message</code>：用于访问正在处理的完整消息。</li>
<li><code>MessageHeaders</code>：用于访问所有消息头。</li>
<li><code>MessageHeaderAccessor</code>、<code>SimpMessageHeaderAccessor</code>、<code>StompHeaderAccessor</code>：通过类型化访问器方法访问消息头。</li>
<li><code>@Payload</code>：用于访问消息的有效负载，由已配置的<code>MessageConverter</code>转换。如果方法只有一个参数，则默认就是该参数，这时标注可省略。</li>
<li><code>@Header</code>：用于访问特定的头值。</li>
<li><code>@Headers</code>：用于访问消息中的所有头。此参数必须是<code>java.util.Map</code>。</li>
<li><code>@DestinationVariable</code>：用于访问从消息destination中提取的模板变量。根据需要将值转换为声明的方法参数类型。</li>
<li><code>java.security.Principal</code>：反映WebSocket HTTP握手时登录的用户。</li>
</ul>
<h4 id="消息负载转换器"><a href="#消息负载转换器" class="headerlink" title="消息负载转换器"></a>消息负载转换器</h4><p>因为我们现在处理的不是HTTP，所以无法使用Spring的<code>HttpMessageConverter</code>实现将负载转换为<code>Shout</code>对象。Spring 4.0提供了几个消息转换器用于将消息负载转换为Java对象：</p>
<table>
<thead>
<tr>
<th>消息转换器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ByteArrayMessageConverter</td>
<td>实现MIME类型<code>application/octet-stream</code>的消息与<code>byte[]</code>之间的相互转换。</td>
</tr>
<tr>
<td>MappingJackson2MessageConverter</td>
<td>实现MIME类型<code>application/json</code>的消息与Java对象之间的相互转换。</td>
</tr>
<tr>
<td>StringMessageConverter</td>
<td>实现MIME类型<code>text/plain</code>的消息与<code>String</code>之间的相互转换。</td>
</tr>
</tbody></table>
<h3 id="向客户端发送消息"><a href="#向客户端发送消息" class="headerlink" title="向客户端发送消息"></a>向客户端发送消息</h3><h4 id="在处理消息之后发送消息"><a href="#在处理消息之后发送消息" class="headerlink" title="在处理消息之后发送消息"></a>在处理消息之后发送消息</h4><p><code>@SubscribeMapping</code>方法与<code>@MessageMapping</code>方法如果没有返回值（即<code>void</code>），则它们的任务只是处理消息，并不需要给客户端回应。如果想要在接收消息的时候，同时在响应中发送一条消息，则只需要将响应内容通过返回值返回。</p>
<p><code>@MessageMapping</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/marco"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Shout <span class="title">handleShout</span><span class="params">(Shout incoming)</span> </span>&#123;</span><br><span class="line">  logger.info(<span class="string">"Received message: "</span> + incoming.getMessage());</span><br><span class="line">  Shout outgoing = <span class="keyword">new</span> Shout();</span><br><span class="line">  outgoing.setMessage(<span class="string">"Polo!"</span>);</span><br><span class="line">  <span class="keyword">return</span> outgoing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SubscribeMapping</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SubscribeMapping</span>(<span class="string">"/marco"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Shout <span class="title">handleSubscription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Shout outgoing = <span class="keyword">new</span> Shout();</span><br><span class="line">  outgoing.setMessage(<span class="string">"Polo!"</span>);</span><br><span class="line">  <span class="keyword">return</span> outgoing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handleShout</code>方法接收<code>destination</code> 头为<code>/app/marco</code>的消息，然后将返回的对象转换为STOMP帧通过brokerChannel发往目的地<code>/topic/marco</code>。</p>
<p><code>handleSubscription</code>方法也接收<code>destination</code> 头为<code>/app/marco</code>的消息，但由于它标有<code>@SubscribeMapping</code>，因此，它将返回对象进行转换并直接发送回客户端，而不通过消息代理。</p>
<h5 id="重载目的地"><a href="#重载目的地" class="headerlink" title="重载目的地"></a>重载目的地</h5><p><code>@SubscribeMapping</code>方法与<code>@MessageMapping</code>方法都可以通过<code>@SendTo</code>标注重载通过返回值响应的消息的目的地：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/marco"</span>)</span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"/topic/shout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Shout <span class="title">handleShout</span><span class="params">(Shout incoming)</span> </span>&#123;</span><br><span class="line">  logger.info(<span class="string">"Received message: "</span> + incoming.getMessage());</span><br><span class="line">  Shout outgoing = <span class="keyword">new</span> Shout();</span><br><span class="line">  outgoing.setMessage(<span class="string">"Polo!"</span>);</span><br><span class="line">  <span class="keyword">return</span> outgoing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handleShout</code>方法通过<code>@SendTo</code>标注将消息目的地重载为<code>/topic/shout</code>（默认是<code>/topic/marco</code>）。</p>
<p>通过<code>@SendTo</code>标注重载目的地后，<code>@SubscribeMapping</code>方法也将返回的对象转换为STOMP帧通过brokerChannel发往目的地<code>/topic/marco</code>，而不是直接发送回客户端。</p>
<h4 id="在应用的任意地方发送消息"><a href="#在应用的任意地方发送消息" class="headerlink" title="在应用的任意地方发送消息"></a>在应用的任意地方发送消息</h4><p>Spring的<code>SimpMessagingTemplate</code>能够在应用的任何地方通过消息代理（经过clientInboundChannel，而不是brokerChannel）发送消息给客户端，甚至不必以首先接收一条消息作为前提。</p>
<p>例如，为了在Spittr首页提供实时的Spittle feed功能，可以在首页订阅一个STOMP主题，当<code>Spittle</code>创建时，该主题能够收到<code>Spittle</code>更新的实时feed。</p>
<p>在首页添加如下JavaScript代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> sock = <span class="keyword">new</span> SockJS(<span class="string">'spittr'</span>);</span><br><span class="line"><span class="keyword">var</span> stomp = webstomp.over(sock);</span><br><span class="line">stomp.connect(<span class="string">'guest'</span>, <span class="string">'guest'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">frame</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Connected'</span>);</span><br><span class="line">  stomp.subscribe(<span class="string">"/topic/spittlefeed"</span>, handleSpittle);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleSpittle</span>(<span class="params">incoming</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> spittle = <span class="built_in">JSON</span>.parse(incoming.body);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received: '</span>, spittle);</span><br><span class="line">  <span class="keyword">var</span> source = $(<span class="string">"#spittle-template"</span>).html();</span><br><span class="line">  <span class="keyword">var</span> template = Handlebars.compile(source);</span><br><span class="line">  <span class="keyword">var</span> spittleHtml = template(spittle);</span><br><span class="line">  $(<span class="string">'.spittleList'</span>).prepend(spittleHtml);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>Handlebars模板定义在另一个单独的<code>&lt;script&gt;</code>中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"spittle-template"</span> <span class="attr">type</span>=<span class="string">"text/x-handlebars-template"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"preexist"</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"spittleMessage"</span>&gt;</span></span><span class="template-variable">&#123;&#123;message&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"spittleTime"</span>&gt;</span></span><span class="template-variable">&#123;&#123;time&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"spittleLocation"</span>&gt;</span>(</span><span class="template-variable">&#123;&#123;latitude&#125;&#125;</span><span class="xml">, </span><span class="template-variable">&#123;&#123;longitude&#125;&#125;</span><span class="xml">)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在服务端，我们可以使用<code>SimpMessagingTemplate</code>将所有新创建的<code>Spittle</code>以消息的形式发布到<code>/topic/spittlefeed</code>主题上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleFeedServiceImpl</span> <span class="keyword">implements</span> <span class="title">SpittleFeedService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SimpMessageSendingOperations messaging;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SpittleFeedServiceImpl</span><span class="params">(SimpMessageSendingOperations messaging)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messaging = messaging;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastSpittle</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">    messaging.convertAndSend(<span class="string">"/topic/spittlefeed"</span>, spittle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：配置Spring支持STOMP时，会自动在Spring应用上下文中包含<code>SimpMessagingTemplate</code> Bean，不需要再创建一个新的实例。</p>
</blockquote>
<p>不管是通过什么方式向客户端发送消息，只要发送的消息是通过消息代理进行广播的，客户端都可以通过订阅来获取该消息。</p>
<h3 id="为目标用户发送消息"><a href="#为目标用户发送消息" class="headerlink" title="为目标用户发送消息"></a>为目标用户发送消息</h3><p>为了向目标用户发送消息，需要结合Spring Security来认证用户。</p>
<h4 id="在控制器中处理用户信息"><a href="#在控制器中处理用户信息" class="headerlink" title="在控制器中处理用户信息"></a>在控制器中处理用户信息</h4><p>在消息处理器方法中添加一个<code>Principal</code>参数，就可以获取发送请求的认证用户信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/spittle"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Notification <span class="title">handleSpittle</span><span class="params">(Principal principal, SpittleForm form)</span> </span>&#123;</span><br><span class="line">  Spittle spittle = <span class="keyword">new</span> Spittle(principal.getName(), form.getText(), <span class="keyword">new</span> Date());</span><br><span class="line">  spittleRepo.save(spittle);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Notification(<span class="string">"Saved Spittle"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-SendToUser向指定用户发送消息"><a href="#通过-SendToUser向指定用户发送消息" class="headerlink" title="通过@SendToUser向指定用户发送消息"></a>通过<code>@SendToUser</code>向指定用户发送消息</h4><p>消息处理器方法还可以使用<code>@SendToUser</code>标注（可标注在方法或类型上），来表明它的返回值要以消息的形式发送给某个认证用户或某个会话（Session）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/spittle"</span>)</span><br><span class="line"><span class="meta">@SendToUser</span>(<span class="string">"/queue/notifications"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Notification <span class="title">handleSpittle</span><span class="params">(Principal principal, SpittleForm form)</span> </span>&#123;</span><br><span class="line">  Spittle spittle = <span class="keyword">new</span> Spittle(principal.getName(), form.getText(), <span class="keyword">new</span> Date());</span><br><span class="line">  spittleRepo.save(spittle);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Notification(<span class="string">"Saved Spittle"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内部，消息发送到目的地<code>/user/{username}/queue/notifications</code>。然后，以“/user”作为前缀的目的地，将由<code>UserDestinationMessageHandler</code>将其转换为一个或多个目的地（例如：<code>/queue/notifications-user6hr83v6t</code>。同一个用户可能会同时存在多个会话），每个目的地对应于与用户相关联的每个会话。</p>
<p>客户端可以通过如下目的地来订阅上面处理器方法发布的消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stompClient.subscribe(<span class="string">"/user/queue/notifications"</span>, handleNotifications);</span><br></pre></td></tr></table></figure>

<p>在内部，上面客户端请求的目的地以“/user”作为前缀，将通过<code>UserDestinationMessageHandler</code>重新路由到某个用户专有的目的地上（将目标地址中的“/user”前缀去掉，并基于用户的会话添加一个后缀，例如：<code>/queue/notifications-user6hr83v6t</code>）。</p>
<p><img src="SpringMessage/UserDestinationMessageHandler.png" alt="UserDestinationMessageHandler"></p>
<p>如果用户具有多个会话，则默认情况下，该用户的所有会话都可以使用相同的目的地（例如<code>/user/queue/notifications</code>）来订阅这条消息。但是，有时，可能需要限制仅有原先在该目的地上发布消息的会话可以订阅该目的地上的消息。您可以通过将<code>broadcast</code>属性设置为<code>false</code>来实现此目的，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@MessageMapping</span>(<span class="string">"/action"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAction</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// raise MyBusinessException here</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MessageExceptionHandler</span></span><br><span class="line">  <span class="meta">@SendToUser</span>(destinations=<span class="string">"/queue/errors"</span>, broadcast=<span class="keyword">false</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ApplicationError <span class="title">handleException</span><span class="params">(MyBusinessException exception)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> appError;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然user destinations通常意味着经过身份验证的用户，但并不是严格要求的。与经过身份验证的用户无关的WebSocket会话可以订阅user destinations。在这种情况下，<code>@SendToUser</code>标注的行为与<code>broadcast = false</code>完全相同（即，仅定位发送正在处理的消息的会话）。</p>
</blockquote>
<h4 id="在应用的任意地方向指定用户发送消息"><a href="#在应用的任意地方向指定用户发送消息" class="headerlink" title="在应用的任意地方向指定用户发送消息"></a>在应用的任意地方向指定用户发送消息</h4><p>借助消息模板（例如：<code>SimpMessagingTemplate</code>的<code>convertAndSendToUser</code>方法），您可以从任何应用程序组件向特定用户发送消息。</p>
<p>例如，在Spittr应用中，当其他用户提交的Spittle提到某个用户时，将会提醒该用户。也就是说，如果Spittle文本中包含“@jbauer”，那么我们就应该发送一条消息给使用“jbauer”用户名登录的客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleFeedServiceImpl</span> <span class="keyword">implements</span> <span class="title">SpittleFeedService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SimpMessagingTemplate messaging;</span><br><span class="line">  <span class="keyword">private</span> Pattern pattern = Pattern.compile(<span class="string">"\\@(\\S+)"</span>); <span class="comment">//匹配用户提及功能的正则表达式</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SpittleFeedServiceImpl</span><span class="params">(SimpMessagingTemplate messaging)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messaging = messaging;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastSpittle</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">    messaging.convertAndSend(<span class="string">"/topic/spittlefeed"</span>, spittle);</span><br><span class="line">    Matcher matcher = pattern.matcher(spittle.getMessage());</span><br><span class="line">    <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">      String username = matcher.group(<span class="number">1</span>);</span><br><span class="line">      messaging.convertAndSendToUser(  <span class="comment">//发送提醒给用户</span></span><br><span class="line">        username, <span class="string">"/queue/notifications"</span>, <span class="comment">//内部是发送到“/user/用户名/queue/notifications”目的地</span></span><br><span class="line">        <span class="keyword">new</span> Notification(<span class="string">"You just got mentioned!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理消息异常"><a href="#处理消息异常" class="headerlink" title="处理消息异常"></a>处理消息异常</h3><p>在处理消息的时候，有可能会出错并抛出异常。但是，由于STOMP消息异步的特点，发送者可能永远也不会知道出现了错误。除了Spring的日志记录以外，异常有可能会丢失，没有资源或机会恢复。类似于Spring MVC中的<code>@ExceptionHandler</code>，我们也可以在某个控制器方法上添加<code>@MessageExceptionHandler</code>标注，让它来处理<code>@MessageMapping</code>或<code>@SubscribeMapping</code>等消息处理器方法抛出的异常。</p>
<p>处理消息处理器方法抛出的任何异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MessageExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleExceptions</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">  logger.error(<span class="string">"Error handling message: "</span> + t.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理消息处理器方法抛出的指定一个或多个异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MessageExceptionHandler</span>(SpittleException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">MessageExceptionHandler</span>(</span>&#123;SpittleException<span class="class">.<span class="keyword">class</span>, <span class="title">DatabaseException</span>.<span class="title">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<p>将错误发送给指定用户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MessageExceptionHandler</span>(SpittleException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@SendToUser("/queue/errors")  //UserDestinationMessageHandler会重新路由这个消息到特定用户所对应的唯一目的地</span><br><span class="line"><span class="function"><span class="keyword">public</span> SpittleException <span class="title">handleExceptions</span><span class="params">(SpittleException e)</span> </span>&#123;</span><br><span class="line">  logger.error(<span class="string">"Error handling message: "</span> + e.getMessage());</span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h1><p>Spring的<code>MailSender</code>接口是Spring Email抽象API的核心组件，它把Email发送给邮件服务器，由服务器进行邮件投递。</p>
<p><img src="SpringMessage/MailSender.png" alt="MailSender"></p>
<p>Spring自带了一个<code>MailSender</code>的实现——<code>JavaMailSenderImpl</code>，它会使用JavaMail API来发送Email。</p>
<h2 id="配置邮件发送器"><a href="#配置邮件发送器" class="headerlink" title="配置邮件发送器"></a>配置邮件发送器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MailSender <span class="title">mailSender</span><span class="params">(Environment env)</span> </span>&#123;</span><br><span class="line">  JavaMailSenderImpl mailSender = <span class="keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">  mailSender.setHost(env.getProperty(<span class="string">"mailserver.host"</span>)); <span class="comment">//默认为底层JavaMail会话的主机</span></span><br><span class="line">  mailSender.setPort(env.getProperty(<span class="string">"mailserver.port"</span>)); <span class="comment">//默认为25</span></span><br><span class="line">  mailSender.setUsername(env.getProperty(<span class="string">"mailserver.username"</span>));</span><br><span class="line">  mailSender.setPassword(env.getProperty(<span class="string">"mailserver.password"</span>));</span><br><span class="line">  <span class="keyword">return</span> mailSender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在JNDI中已经配置了<code>javax.mail.MailSession</code>，则先注册一个<code>JndiObjectFactoryBean</code>，它会从JNDI中查找MailSession：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JndiObjectFactoryBean <span class="title">mailSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  JndiObjectFactoryBean jndi = <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">  jndi.setJndiName(<span class="string">"mail/Session"</span>);</span><br><span class="line">  jndi.setProxyInterface(MailSession<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  jndi.setResourceRef(<span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">return</span> jndi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"mailSession"</span> <span class="attr">jndi-name</span>=<span class="string">"mail/Session"</span> <span class="attr">resource-ref</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，将<code>MailSession</code> Bean装配到<code>MailSender</code> Bean中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MailSender <span class="title">mailSender</span><span class="params">(MailSession mailSession)</span> </span>&#123;</span><br><span class="line">  JavaMailSenderImpl mailSender = <span class="keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">  mailSender.setSession(mailSession);</span><br><span class="line">  <span class="keyword">return</span> mailSender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用邮件发送器"><a href="#使用邮件发送器" class="headerlink" title="使用邮件发送器"></a>使用邮件发送器</h2><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>邮件发送器已经配置完成，现在只需要将它装配到使用它的Bean中，就可以利用它构建和发送Email了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSimpleSpittleEmail</span><span class="params">(String to, Spittle spittle)</span> </span>&#123;</span><br><span class="line">  SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage(); <span class="comment">//构建邮件</span></span><br><span class="line">  String spitterName = spittle.getSpitter().getFullName();</span><br><span class="line">  message.setFrom(<span class="string">"noreply@spitter.com"</span>); <span class="comment">//发件人邮箱</span></span><br><span class="line">  message.setTo(to); <span class="comment">//收件人邮箱</span></span><br><span class="line">  message.setSubject(<span class="string">"New spittle from "</span> + spitterName); <span class="comment">//邮件主题</span></span><br><span class="line">  message.setText(spitterName + <span class="string">" says: "</span> + spittle.getText()); <span class="comment">//邮件正文</span></span><br><span class="line">  mailSender.send(message); <span class="comment">//发送邮件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加附件"><a href="#添加附件" class="headerlink" title="添加附件"></a>添加附件</h3><p>发送带有附件的Email的关键技巧是创建multipart类型的消息——Email由多个部分组成，其中一个部分是Email体，其他部分是附件。</p>
<p>为了发送multipart类型的Email，你需要创建一个MIME的消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MimeMessage message = mailSender.createMimeMessage();</span><br></pre></td></tr></table></figure>

<p>由于<code>javax.mail.internet.MimeMessage</code>本身的API有些笨重，Spring提供了<code>MimeMessageHelper</code>来帮助简化使用MIME消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(message, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>构造器的第二个参数为<code>true</code>表明这个消息是multipart类型的。</p>
<p>为了添加附件，我们需要将文件加载为资源，然后将这个资源传递给<code>addAttachment</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileSystemResource couponImage = <span class="keyword">new</span> FileSystemResource(<span class="string">"/collateral/coupon.png"</span>);</span><br><span class="line">helper.addAttachment(<span class="string">"Coupon.png"</span>, couponImage);</span><br></pre></td></tr></table></figure>

<p><code>addAttachment</code>方法的第一个参数是要添加到Email中的附件名称，第二个参数是图片资源。</p>
<p>完整的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSpittleEmailWithAttachment</span><span class="params">(String to, Spittle spittle)</span> </span></span><br><span class="line"><span class="function">  	<span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">  MimeMessage message = mailSender.createMimeMessage();</span><br><span class="line">  MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(message, <span class="keyword">true</span>);</span><br><span class="line">  String spitterName = spittle.getSpitter().getFullName();</span><br><span class="line">  helper.setFrom(<span class="string">"noreply@spitter.com"</span>);</span><br><span class="line">  helper.setTo(to);</span><br><span class="line">  helper.setSubject(<span class="string">"New spittle from "</span> + spitterName);</span><br><span class="line">  helper.setText(spitterName + <span class="string">" says: "</span> + spittle.getText());</span><br><span class="line">  FileSystemResource couponImage = <span class="keyword">new</span> FileSystemResource(<span class="string">"/collateral/coupon.png"</span>);</span><br><span class="line">  helper.addAttachment(<span class="string">"Coupon.png"</span>, couponImage);</span><br><span class="line">  mailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送富文本内容的Email"><a href="#发送富文本内容的Email" class="headerlink" title="发送富文本内容的Email"></a>发送富文本内容的Email</h3><p>发送富文本的Email与发送简单文本的Email并没有太大的区别。关键是将消息的文本设置为HTML。要做到这一点只需要将HTML字符串传递给helper的<code>setText</code>方法，并将第二个参数设置为<code>true</code>（表明传递进来的第一个参数是HTML）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRichSpitterEmail</span><span class="params">(String to, Spittle spittle)</span></span></span><br><span class="line"><span class="function">  	<span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">  MimeMessage message = mailSender.createMimeMessage(); <span class="comment">//创建一个MIME的消息</span></span><br><span class="line">  MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(message, <span class="keyword">true</span>);</span><br><span class="line">  helper.setFrom(<span class="string">"noreply@spitter.com"</span>);</span><br><span class="line">  helper.setTo(<span class="string">"craig@habuma.com"</span>);</span><br><span class="line">  helper.setSubject(<span class="string">"New spittle from "</span> + spittle.getSpitter().getFullName());</span><br><span class="line">  <span class="comment">//设置HTML邮件内容</span></span><br><span class="line">  helper.setText(<span class="string">"&lt;html&gt;&lt;body&gt;&lt;img src='cid:spitterLogo'&gt;"</span> +</span><br><span class="line">                 <span class="string">"&lt;h4&gt;"</span> + spittle.getSpitter().getFullName() + <span class="string">" says...&lt;/h4&gt;"</span> +</span><br><span class="line">                 <span class="string">"&lt;i&gt;"</span> + spittle.getText() + <span class="string">"&lt;/i&gt;"</span> +</span><br><span class="line">                 <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>, <span class="keyword">true</span>);</span><br><span class="line">  ClassPathResource image = <span class="keyword">new</span> ClassPathResource(<span class="string">"spitter_logo_50.png"</span>);</span><br><span class="line">  helper.addInline(<span class="string">"spitterLogo"</span>, image); <span class="comment">//添加内联图片</span></span><br><span class="line">  mailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，传递进来的HTML包含一个<code>&lt;img&gt;</code>标签，它的<code>src</code>属性可以设置为标准的“http://” URL。但在这里，我们将图片嵌入到Email中。值<code>cid:spitterLogo</code>表明在消息中会有一部分是图片并以<code>spitterLogo</code>来进行标识。</p>
<p>为消息添加嵌入式的图片与添加附件很类似，只不过是调用<code>addInline</code>方法。</p>
<h2 id="使用模板生成Email"><a href="#使用模板生成Email" class="headerlink" title="使用模板生成Email"></a>使用模板生成Email</h2><p>除了使用字符串拼接方式构建Email外，更好的方式是使用模板来生成Email。</p>
<p>这边使用Thymeleaf HTML模板引擎。</p>
<h3 id="配置Thymeleaf"><a href="#配置Thymeleaf" class="headerlink" title="配置Thymeleaf"></a>配置Thymeleaf</h3><p>在《SpringWeb》中配置的Thymeleaf是从Servlet上下文中解析模板的，而我们的Email模板需要从类路径中解析。因此，除了配置原来的三个Bean（<code>ThymeleafViewResolver</code>、<code>SpringTemplateEngine</code>和<code>ServletContextTemplateResolver</code>）之外，还需要一个<code>ClassLoaderTemplateResolver</code> Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoaderTemplateResolver <span class="title">emailTemplateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ClassLoaderTemplateResolver resolver = <span class="keyword">new</span> ClassLoaderTemplateResolver();</span><br><span class="line">  resolver.setPrefix(<span class="string">"mail/"</span>);</span><br><span class="line">  resolver.setTemplateMode(<span class="string">"HTML5"</span>);</span><br><span class="line">  resolver.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">  setOrder(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将<code>prefix</code>属性设置为“mail/”，这表明它会在类路径根的“mail”目录下查找Thymeleaf模板。</p>
<p>因为我们现在有两个模板解析器，所以需要使用<code>order</code>属性表明优先使用哪一个。<code>ClassLoaderTemplateResolver</code>的<code>order</code>属性为1，因此我们要修改一下<code>ServletContextTemplateResolver</code> Bean，将其<code>order</code>属性设置为2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletContextTemplateResolver <span class="title">webTemplateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ServletContextTemplateResolver resolver = <span class="keyword">new</span> ServletContextTemplateResolver();</span><br><span class="line">  resolver.setPrefix(<span class="string">"/WEB-INF/templates/"</span>);</span><br><span class="line">  resolver.setTemplateMode(<span class="string">"HTML5"</span>);</span><br><span class="line">  resolver.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">  setOrder(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，还要修改<code>SpringTemplateEngine</code> Bean的配置，让它使用这两个模板解析器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">(Set&lt;ITemplateResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">  SpringTemplateEngine engine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">  engine.setTemplateResolvers(resolvers);</span><br><span class="line">  <span class="keyword">return</span> engine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>templateEngine</code>方法的参数是一个<code>Set&lt;ITemplateResolver&gt;</code>，它能将应用上下文中所有匹配<code>ITemplateResolver</code>的Bean都装配进来。</p>
<h3 id="创建Email模板"><a href="#创建Email模板" class="headerlink" title="创建Email模板"></a>创建Email模板</h3><p>在类路径根的“mail”目录下创建名为<code>emailTemplate.html</code>的邮件模板：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"spitterLogo.png"</span> <span class="attr">th:src</span>=<span class="string">'cid:spitterLogo'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;spitterName&#125;"</span>&gt;</span>Craig Walls<span class="tag">&lt;/<span class="name">span</span>&gt;</span> says...<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;spittleText&#125;"</span>&gt;</span>Hello there!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用模板生成和发送Email"><a href="#使用模板生成和发送Email" class="headerlink" title="使用模板生成和发送Email"></a>使用模板生成和发送Email</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SpringTemplateEngine thymeleaf;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSimpleSpittleEmail</span><span class="params">(String to, Spittle spittle)</span> </span>&#123;</span><br><span class="line">  Context ctx = <span class="keyword">new</span> Context();</span><br><span class="line">  ctx.setVariable(<span class="string">"spitterName"</span>, spitterName);</span><br><span class="line">  ctx.setVariable(<span class="string">"spittleText"</span>, spittle.getText());</span><br><span class="line">  <span class="comment">//将上下文中的模型数据合并到模板中</span></span><br><span class="line">  String emailText = thymeleaf.process(<span class="string">"emailTemplate.html"</span>, ctx);</span><br><span class="line">  ...</span><br><span class="line">  helper.setText(emailText, <span class="keyword">true</span>);</span><br><span class="line">  mailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/12/03/SpringRemoting/" rel="prev" title="SpringRemoting">
      <i class="fa fa-chevron-left"></i> SpringRemoting
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/12/27/SpringJMX/" rel="next" title="SpringJMX">
      SpringJMX <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#消息模型"><span class="nav-number">1.</span> <span class="nav-text">消息模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#点对点模型"><span class="nav-number">1.1.</span> <span class="nav-text">点对点模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布-订阅模型"><span class="nav-number">1.2.</span> <span class="nav-text">发布&#x2F;订阅模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JMS"><span class="nav-number">2.</span> <span class="nav-text">JMS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装消息代理"><span class="nav-number">2.1.</span> <span class="nav-text">安装消息代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建连接工厂"><span class="nav-number">2.2.</span> <span class="nav-text">创建连接工厂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明消息目的地"><span class="nav-number">2.3.</span> <span class="nav-text">声明消息目的地</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明队列"><span class="nav-number">2.3.1.</span> <span class="nav-text">声明队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明主题"><span class="nav-number">2.3.2.</span> <span class="nav-text">声明主题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用传统的JMS"><span class="nav-number">2.4.</span> <span class="nav-text">使用传统的JMS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发送消息"><span class="nav-number">2.4.1.</span> <span class="nav-text">发送消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收消息"><span class="nav-number">2.4.2.</span> <span class="nav-text">接收消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用JmsTemplate"><span class="nav-number">2.5.</span> <span class="nav-text">使用JmsTemplate</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注册JmsTemplate-Bean"><span class="nav-number">2.5.1.</span> <span class="nav-text">注册JmsTemplate Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设置默认目的地"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">设置默认目的地</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送消息-1"><span class="nav-number">2.5.2.</span> <span class="nav-text">发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对消息进行转换"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">对消息进行转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收消息-1"><span class="nav-number">2.5.3.</span> <span class="nav-text">接收消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步接收"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">同步接收</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用消息驱动POJO：异步接收"><span class="nav-number">2.6.</span> <span class="nav-text">使用消息驱动POJO：异步接收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建消息监听器"><span class="nav-number">2.6.1.</span> <span class="nav-text">创建消息监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置消息监听器"><span class="nav-number">2.6.2.</span> <span class="nav-text">配置消息监听器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用基于消息的RPC"><span class="nav-number">2.7.</span> <span class="nav-text">使用基于消息的RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#导出基于JMS的服务"><span class="nav-number">2.7.1.</span> <span class="nav-text">导出基于JMS的服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用基于JMS的服务"><span class="nav-number">2.7.2.</span> <span class="nav-text">使用基于JMS的服务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AMQP"><span class="nav-number">3.</span> <span class="nav-text">AMQP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建连接工厂-1"><span class="nav-number">3.1.</span> <span class="nav-text">创建连接工厂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明队列、Exchange以及binding"><span class="nav-number">3.2.</span> <span class="nav-text">声明队列、Exchange以及binding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发送消息-2"><span class="nav-number">3.3.</span> <span class="nav-text">发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注册RabbitTemplate"><span class="nav-number">3.3.1.</span> <span class="nav-text">注册RabbitTemplate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用convertAndSend方法发送消息"><span class="nav-number">3.3.2.</span> <span class="nav-text">使用convertAndSend方法发送消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用send方法发送消息"><span class="nav-number">3.3.3.</span> <span class="nav-text">使用send方法发送消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接收消息-2"><span class="nav-number">3.4.</span> <span class="nav-text">接收消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用RabbitTemplate来同步接收消息"><span class="nav-number">3.4.1.</span> <span class="nav-text">使用RabbitTemplate来同步接收消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注册RabbitTemplate-1"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">注册RabbitTemplate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用receive方法接收消息"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">使用receive方法接收消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用receiveAndConvert方法接收消息"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">使用receiveAndConvert方法接收消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管理轮询"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">管理轮询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用消息驱动的POJO来异步接收消息"><span class="nav-number">3.4.2.</span> <span class="nav-text">使用消息驱动的POJO来异步接收消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建消息监听器POJO类"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">创建消息监听器POJO类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#配置消息监听器-1"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">配置消息监听器</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebSocket"><span class="nav-number">4.</span> <span class="nav-text">WebSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Spring的低层级WebSocket-API"><span class="nav-number">4.1.</span> <span class="nav-text">使用Spring的低层级WebSocket API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建消息处理器"><span class="nav-number">4.1.1.</span> <span class="nav-text">创建消息处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启用WebSocket"><span class="nav-number">4.1.2.</span> <span class="nav-text">启用WebSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript客户端"><span class="nav-number">4.1.3.</span> <span class="nav-text">JavaScript客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭WebSocket连接"><span class="nav-number">4.1.4.</span> <span class="nav-text">关闭WebSocket连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应对不支持WebSocket的场景——SockJS"><span class="nav-number">4.2.</span> <span class="nav-text">应对不支持WebSocket的场景——SockJS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在服务端启用SockJS"><span class="nav-number">4.2.1.</span> <span class="nav-text">在服务端启用SockJS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在客户端启用SockJS"><span class="nav-number">4.2.2.</span> <span class="nav-text">在客户端启用SockJS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#加载SockJS客户端库"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">加载SockJS客户端库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编写客户端代码"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">编写客户端代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用STOMP消息"><span class="nav-number">4.3.</span> <span class="nav-text">使用STOMP消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启用STOMP消息功能"><span class="nav-number">4.3.1.</span> <span class="nav-text">启用STOMP消息功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启用STOMP代理中继"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">启用STOMP代理中继</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写JavaScript客户端"><span class="nav-number">4.3.2.</span> <span class="nav-text">编写JavaScript客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发送消息-3"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#发往控制器方法"><span class="nav-number">4.3.2.1.1.</span> <span class="nav-text">发往控制器方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#发往代理"><span class="nav-number">4.3.2.1.2.</span> <span class="nav-text">发往代理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#订阅消息"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">订阅消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理来自客户端的STOMP消息"><span class="nav-number">4.3.3.</span> <span class="nav-text">处理来自客户端的STOMP消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageMapping方法"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">@MessageMapping方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SubscribeMapping方法"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">@SubscribeMapping方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息处理器方法参数"><span class="nav-number">4.3.3.3.</span> <span class="nav-text">消息处理器方法参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息负载转换器"><span class="nav-number">4.3.3.4.</span> <span class="nav-text">消息负载转换器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向客户端发送消息"><span class="nav-number">4.3.4.</span> <span class="nav-text">向客户端发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在处理消息之后发送消息"><span class="nav-number">4.3.4.1.</span> <span class="nav-text">在处理消息之后发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#重载目的地"><span class="nav-number">4.3.4.1.1.</span> <span class="nav-text">重载目的地</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在应用的任意地方发送消息"><span class="nav-number">4.3.4.2.</span> <span class="nav-text">在应用的任意地方发送消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为目标用户发送消息"><span class="nav-number">4.3.5.</span> <span class="nav-text">为目标用户发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在控制器中处理用户信息"><span class="nav-number">4.3.5.1.</span> <span class="nav-text">在控制器中处理用户信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过-SendToUser向指定用户发送消息"><span class="nav-number">4.3.5.2.</span> <span class="nav-text">通过@SendToUser向指定用户发送消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在应用的任意地方向指定用户发送消息"><span class="nav-number">4.3.5.3.</span> <span class="nav-text">在应用的任意地方向指定用户发送消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理消息异常"><span class="nav-number">4.3.6.</span> <span class="nav-text">处理消息异常</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Email"><span class="nav-number">5.</span> <span class="nav-text">Email</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#配置邮件发送器"><span class="nav-number">5.1.</span> <span class="nav-text">配置邮件发送器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用邮件发送器"><span class="nav-number">5.2.</span> <span class="nav-text">使用邮件发送器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发送邮件"><span class="nav-number">5.2.1.</span> <span class="nav-text">发送邮件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加附件"><span class="nav-number">5.2.2.</span> <span class="nav-text">添加附件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送富文本内容的Email"><span class="nav-number">5.2.3.</span> <span class="nav-text">发送富文本内容的Email</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用模板生成Email"><span class="nav-number">5.3.</span> <span class="nav-text">使用模板生成Email</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置Thymeleaf"><span class="nav-number">5.3.1.</span> <span class="nav-text">配置Thymeleaf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Email模板"><span class="nav-number">5.3.2.</span> <span class="nav-text">创建Email模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用模板生成和发送Email"><span class="nav-number">5.3.3.</span> <span class="nav-text">使用模板生成和发送Email</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">周千涵</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:supremeadministrator@supercalifragilisticexpialidociouser.com" title="E-Mail → mailto:supremeadministrator@supercalifragilisticexpialidociouser.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">周千涵</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
