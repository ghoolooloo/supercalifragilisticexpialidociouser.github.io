---
title: C
date: 2018-06-26 10:22:06
tags: [C11]
---

# 简介

C语言是一门很接近底层的高级语言，是高性能计算的主要选择，例如：系统编程。

# 入门

## 开发环境

### 编译器

C的编译器可以选择gcc，也可以选择clang。

安装好gcc或clang后，可以将它们链接到名为cc（通常放在`/usr/bin/cc`）的默认编译器。

可以通过下面命令来查看编译器的版本：

```bash
$ cc --version
$ gcc --version
$ clang --version
```

### 交互式环境——REPL

无 

### 调试器——GDB

### IDE

### 静态代码分析工具——lint/splint



## 程序结构

C程序主要由函数组成，函数定义不能嵌套，但函数可以调用其他函数，函数包含循序执行语句。

C程序的顶层结构包含：

- 注释
- 预处理指令
- 全局声明
- 函数定义

### 保留字

![C语言保留字](C/C语言保留字.png)

### 注释

```c
// 单行注释以//开始直到行尾。（仅适用于C99或更新的版本。）

/* 这是块注释，它可以适用于C89。
   块注释可以跨越多行。
   块注释不能再嵌套块注释，但可以嵌套单//行注释。
*/
```

在字符或字符串字面量中的`/*`、`*/`或`//`，不会被视为注释。

如果想要注释掉包含块注释的部分代码，可以使用条件预处理指令：

```c
#if 0
  const double pi = 3.1415926;  /* pi是一个常量 */
  area = pi * r * r;  /* 计算面积 */
#endif
```

预处理器会把每个注释都替换成一个空格。因此，`min/*max*/Value`将变成两个标记：“min Value”。

### 程序入口

每个C程序都必须定义至少一个`main`函数，它是程序开始执行时第一个被调用的函数，是程序结构中最顶层的函数，其他函数会以子例程的方式被它调用。

`main`函数有如下形式：

```c
// 无参形式
int main(void) {…}
int main() {…}

// 带参形式。
// 参数argc表示在命令行中执行main()函数的参数个数，包含程序名在内，argc的值至少是1；
// 参数argv是这些参数名组成的数组。
int main(int argc, char *argv[]) {
  printf("Program name: %s\n", argv[0]); // argv[0]保存着程序名。
  for (int i=1; i<argc; ++i)
     printf("Argument %d: %s\n", i, argv[i]);
  return 0;
}
```

## 编程过程

### 编码

#### 第一个程序——Hello world

hello.c：

```c
#include <stdio.h>

int main(void) {
    printf("Hello world!");
    return 0;
}
```

#### 源文件

C程序的源代码保存在**源文件**中，扩展名通常是`.c`。

另外，可将多个源文件共享的声明和定义保存到一个单独的头文件（header file）中，然后在每个需要的源文件中利用`#include`指令来引用该头文件。头文件习惯上使用扩展名`.h`。 

#### 字符集

C代码是区分大小写的。

编译器转换代码时所处的环境称为翻译环境（translation environment），程序执行时所处的环境称为运行环境（execution environment）。C语言定义了两个字符集：源代码字符集和运行字符集。源代码字符集是用于组成C代码的字符集，而运行字符集是可以被执行程序解释的字符集。在许多C语言的实现中，这两个字符集是一样的。

原本C语言主要使用7位的ASCII码。现在，也可以采用两种表示大型字符集的标准化方法：

- 宽字符（wide character）：每个字符使用相同的位长。虽然C标准没规定宽字符必须使用Unicode字符集，但许多实现使用UTF-16和UTF-32来处理宽字符。
- 多字节字符（multibyte character）：每个字符可以采用一个或多个字节表示。某些多字节字符的编码机制是带状态的，对给定多字节序列的翻译会受到控制字符位置的影响。这种控制字符称为移位序列（shift sequence）。UTF-8不需要使用移位序列。

多字节字符串比宽字符串更难处理。但多字节字符编码独立于系统架构，而宽字符编码是依赖于所给定系统的字节顺序的（即大端和小端字节顺序问题）。

#### 转义序列

##### 通用字符名

通用字符名（universal character name）即字符的Unicode值，与实现的编码格式无关。其格式如下：

```c
\uxxxx   //一个x表示一个十六进制数字
\Uxxxxxxxx
```

通用字符名可以用于标识符、字符常量、字符串字面量，但是不得用于表示基本字符集内的字符。

##### 特殊字符转义序列

| 转义序列 | 字符值     |
| -------- | ---------- |
| `\'`     | 一个单引号 |
| `\"`     | 一个双引号 |
| `\?`     | 一个问号   |
| `\\`     | 一个反斜线 |
| `\a`     | 警告       |
| `\b`     | 退格       |
| `\f`     | 换页       |
| `\n`     | 换行       |
| `\r`     | 回车       |
| `\t`     | 水平制表符 |
| `\v`     | 垂直制表符 |

特殊字符转义序列只能出现在字符字面量或字符串字面量中。

##### 八进制和十六进制转义序列

八进制和十六进制转义序列可以表示`unsigned char`类型的取值范围内的任何字符，或者`wchar_t`类型取值范围内的任何宽字符。

```c
\o、\oo、\ooo  //八进制转义序列。一个o表示一个八进制数字
\x…  //十六进制转义序列。一个x表示一个十六进制数字
```

八进制和十六进制转义序列用法与通用字符名相同。

##### 双字符组

| 双字符组 | 等效字符 |
| -------- | -------- |
| `<:`     | `[`      |
| `:>`     | `]`      |
| `<%`     | `{`      |
| `%>`     | `}`      |
| `%:`     | `#`      |
| `%:%:`   | `##`     |

上述字符出现在字符字面量或字符串字面量中，则不会被解释成双字符组。在其他位置时，才被解释为双字符组。例如：

```c
int arr<::> = <% 10, 20, 30 %>;  //等价于：int arr[] = {10, 20, 30};
```

##### 三字符组

| 三字符组 | 等效字符 |
| -------- | -------- |
| `??(`    | `[`      |
| `??)`    | `]`      |
| `??<`    | `{`      |
| `??>`    | `}`      |
| `??=`    | `#`      |
| `??/`    | `\`      |
| `??!`    | `|`      |
| `??'`    | `^`      |
| `??-`    | `~`      |

三字符组不同于双字符组，它是在预处理阶段被替换成等效字符。并且，它在任何位置都会被解释为三字符组，包括在字符字面量和字符串字面量中。

#### 编码规范

C语言采用自由的编码格式，没有换行或缩排规则。除了预处理指令的格式化自由度会低一些：一条指令必须独占一行，并且`#`符号前面除了空格与制表符之外，不能有别的字符。

一些通用的编码规范：（非强制）

- 每个新的声明和语句都新起一行；
- 使用缩进以反映语句块的嵌套结构。

### 构建

每个C源文件，连同通过`#include`指令引用的头文件，构成一个翻译单元（translation unit）。

编译器将一个C程序的每个翻译单元翻译成一个独立的目标文件（object file）。目标文件的扩展名通常为`.o`或`.obj`。然后，编译器调用链接器（linker）将所有的目标文件和所用到的链接库函数结合起来，成为一个可执行文件（executable file）。

目标文件也称为模块（module）。一个链接库包含了多个编译好的可以快速获取的模块，模块里有许多标准函数。

可以使用下列命令将`hello.c`编译成可执行文件`hello`：

```bash
$ cc hello.c -o hello -g -Wall -O3
```

如果省略`-o hello`，则生成可执行文件名为`a.out`（Windows下为`a.exe`）。

`-Wall`要求编译器输出警告信息，默认只有错误信息才会输出。

`-O3`表示采用三级优化等级。

`-g`表示加入调试符号。如果没有这个选项，调试器就无法显示变量或函数的名字。

使用`-save-temps`选项，会将整个构建过程中产生的中间文件全部输出：

```bash
$ gcc -o hello hello.c -save-temps
```

上述命令将生成：`hello`、`hello.i`、`hello.o`和`hello.s`。

接下来，将介绍如何分别生产每个阶段的中间文件。

如果只是想检测源文件的语法是否正确，而不执行预处理、编译、汇编或链接，则可以使用`-fsyntax-only`选项。

#### 预处理

将源代码提交给编译器之前，由预处理器展开源代码文件中的宏。

可用下列命令查看预处理的结果：

```bash
$ gcc -E -C -o hello.i hello.c
```

在命令中，可以使用`-D宏名[=定义]`方式来定义宏：

```bash
$ gcc hello.c -DFOO
```

省略“=定义”部分，则该宏被定义为值1。

宏`FOO`必须是在源文件和头文件中都没有被定义过的。

该选项经常搭配源代码中的`#ifdef`指令使用，可以实现条件式编译。

相应地，选项`-U宏名` 表示“取消”宏定义。

#### 编译

编译器的核心任务是把C程序翻译成机器的汇编语言。

下列命令可输出翻译的汇编语言文件`hello.s`：

```bash
$ gcc -S hello.c
```

如果想把C语言变量的名称作为汇编语言语句中的注释，可以加上`-fverbose-asm`选项：

```bash
$ gcc -S -fverbose-asm hello.c
```

#### 汇编

在汇编阶段，GCC调用宿主系统的汇编器，把汇编语言翻译成可执行的二进制代码，即输出一个目标文件。

可以使用下列命令输出目标文件`hello.o`：

```bash
$ gcc -c hello.c
```

可以使用GCC的`-Wa`选项（可以有多个）给汇编器传递参数：

```bash
$ gcc -v -o hello -Wa,-as=hello.sym,-L hello.c
```

`-v`：显示编译器调用的程序。

紧跟`-Wa`后面，以逗号开头，中间不能有空格的都是传递给汇编器的参数。`,-as=hello.sym`表示把符号表输出到`hello.sym`文件中。`,-L`表示在符号表中包含本地符号。本地符号指具有内部链接的C标识符。（不要把该汇编器选项与GCC的`-L`选项混淆！）

```bash
$ gcc -g -c -Wa,-a=hello.list,-L hello.c
```

如果没有带`-g`选项，则`hello.list`只会包含生成的二进制代码及相应的汇编语言代码，然后后面再跟上符号表内容。则带上了`-g`选项后，还会将C代码插入到对应的二进制代码和汇编代码之间，从而允许逐行地查看编译器如何把C语句翻译为二进制机器码。

#### 链接

链接器把多个二进制目标文件链接成一个单独的可执行文件。

gcc在编译C代码时，会默认带上`-lc`选项，即默认链接标准库`c`。标准库的大部分函数通常放在文件`libc.a`或动态链接文件`libc.so`中。这些链接库一般位于`/lib/`或`/usr/lib/`，或者位于GCC默认搜索的其他链接库目录。

如果要链接的是非标准的链接库，则必需显式使用`-l`选项。

```bash
$ gcc -o hello hello.c -lncurses
```

上述命令将链接非标准的`ncurses`库，并且将自动在标准库目录中搜索它的库文件`libncurses.a`。

名为`foo`的链接库，它的库文件名必须是`libfoo.a`，即带上前缀`lib` 和后缀`.a`（动态链接库则为`.so`或`.dylib`）。

有三种方式可以链接在GCC搜索路径以外的链接库。

方式一是把链接库作为一般的目标文件：

```bash
$ gcc -o hello hello.c /usr/local/lib/libncurses.a
```

> 在命令中，链接库要放在源文件之后。如果有多个链接库，则被依赖的库，要放在依赖库之前。

方式二是使用`-L`选项来为GCC增加一个搜索链接库的目录：

```bash
$ gcc -o hello -L/usr/local/lib/ -lncurses hello.c
```

在同一命令中，`-L`选项可以有多个，或者在一个`-L`选项内使用冒号分割的路径列表。

方式三是把所需链接库的目录加到环境变量`LIBRARYPATH`中。

通过使用`-Wl`选项（可以有多个）后接一个逗号分隔的列表（中间不能有空格），可以直接将选项传递给链接器，例如：

```bash
$ gcc -lncurses -v -Wl,-Map,hello.map hello.c
```

上述命令指示链接器输出一个链接脚本和一个内在映射。

### 运行

### 调试



# 基本类型

## 数值类型

### 整数类型

### 浮点类型

### 复数浮点类型

## 字符类型

C语言中的字符类型实际上都是整数类型，可以对它们做算术运算。

### 单字节字符

`char`类型表示单字节字符。

### 宽字符

C语言用`wchar_t`类型表示宽字符。当宽字符采用Unicode标准时（即定义了宏`__STDC_ISO_10646__`），`wchar_t`类型至少是16位或32位长，`wchar_t`类型的一个值代表一个Unicode字符。

> 在Windows中，`wchar_t`有2个字节，存储UTF-16编码的字符。

由于`wchar_t`的大小是由实现代码定义，当代码需要在不同的系统之间移植时，这种不确定性和可变性降低了其可用性。因此，C11引入额外的宽字符类型`char16_t`和`char32_t`。它们被定义为无符号整数类型，在定义了宏`_STDC_UTF_16__`的C实现中，类型`char16_t`的字符采用UTF-16编码；在定义了宏`_STDC_UTF_32__`的C实现中，类型`char32_t`的字符采用UTF-32编码。

`wchar_t`字符字面量必须有一个`L`前缀，`char16_t`字符字面量必须有一个`u`前缀，`char32_t`字符字面量必须有一个`U`前缀：

```c
wchar_t w_ch = L'A';
char16_t ch16 = u'A';
char32_t ch32 = U'A';
```

### 多字节字符

C语言中没有专门的多字节字符类型，而是使用`char`数组或`char`指针来存储多字节字符。因此，也没有专门的多字节字符字面量。

C语言提供了一些标准函数，来在宽字符与多字节字符之间转换。

## 布尔类型

## 空类型

C语言中空类型使用`void`表示。

# 声明

## 变量声明

## 常量声明

## 命名规范

# 数组

# 字符串

`wchar_t`字符串字面量需要在左引号前加上`L`前缀，`char16_t`字符串字面量必须有一个`u`前缀，`char32_t`字符串字面量必须有一个`U`前缀，使用UTF-8编码的多字节字符串字面量必须有一个`u8`前缀：

```c
wchar_t proverb[] = L"A nod is as good as a wink to a blind horse.";
char16_t *str16 = u"This is a Unicode string using UTF-16 encoding.";
char32_t *str32 = U"This is a Unicode string using UTF-32 encoding.";
char *str8 = u8"This is a Unicode string using UTF-8 encoding.";
```



# 枚举类型

# 表达式

## 算术表达式

## 关系表达式

## 逻辑表达式

## 赋值表达式

### 交换值

## 位运算表达式

## 条件表达式

# 语句

## 语句结束符

## 表达式语句

## 块语句

## 空语句

## 选择语句

### 条件语句

### 多分支语句

## 循环语句

### while循环

### do-while循环

### for循环

## 跳转语句

# 子程序

## 函数

### 函数定义

函数定义不能嵌套在另一个函数的定义之中。

### 函数声明

## 运算符

### 优先级

### 结合性

# 指针

# 结构

# 联合

## 位字段

# 集合类型

## 列表

## 映射/字典

## 集

# 作用域和可见性

# 内存管理

# 类型系统

## 类型兼容

## 类型转换



## 类型推断

# 别名

## 类型别名

# 输入和输出

# 异常处理

# 断言

# 正则表达式

# 并发编程

# 网络编程

# 国际化和本地化

## 日期和时间

# 元编程

# 预处理指令

## #include

include目录的搜索顺序：

1. 包含指定源文件的目录（只对在`#include`指令中以引号括起来的头文件名进行搜索）。
2. 采用`-iquote 路径1:…:路径N` 选项指定的目录（只对在`#include`指令中以引号括起来的头文件名进行搜索）。
3. 采用`-I 路径1:…:路径N` 选项指定的目录（对所有`#include` 指令中的头文件名进行搜索，无论文件名是在引号中，还是在尖括号中）。
4. 采用环境变量`CPATH`指定的目录。
5. 采用`-isystem 路径1:…:路径N` 选项指定的目录（只对在`#include`指令中以尖括号括起来的头文件名进行搜索）。
6. 采用环境变量`C_INCLUDE_PATH` 指定的目录。
7. 系统默认的include目录。

# 模块

# 构建管理








